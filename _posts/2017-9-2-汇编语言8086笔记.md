---
layout: post
title:  "汇编语言8086笔记"
date:   2017-09-02 19:27:11 +0800
tag: ASM
---
<blockquote>
  <p>学到的知识，很大的一部分会被忘却，而被忘记的知识的影子却保护你避免陷入很多的错觉。——伊顿公学校长威廉·考利</p>
</blockquote>



<h1 id="为什么要学习汇编语言">为什么要学习汇编语言？</h1>

<p>　　汇编语言是很多相关课程的重要基础，比如：操作系统、接口技术等。它是底层编程语言，是计算机系统提供给用户最快最有效的语言，也是能对硬件直接编程的语言。因此，对空间和时间要求很高的程序，或需要直接控制硬件的程序，必须使用汇编语言进行程序设计。</p>

<ul>
<li><a href="http://blog.csdn.net/qq_38176439/article/details/69055718">程序员是个大江湖之我来自编译门 </a></li>
</ul>



<h1 id="汇编语言的特点">汇编语言的特点</h1>

<ol>
<li>面向机器的低级语言，与处理器密切相关。通常是为特定的计算机或计算机系列专门设计的。</li>
<li>保持了机器语言的优点，具有<font color="2196f3"><strong>直接</strong></font>和<font color="2196f3"><strong>简捷</strong></font>的特点。</li>
<li>可有效地访问、控制计算机的各种硬件设备,  如磁盘、存储器、CPU、I/O端口等。</li>
<li>目标代码简短，占用内存少，执行速度快，是<font color="2196f3"><strong>高效</strong></font>的程序设计语言。</li>
<li>经常与高级语言配合使用，应用十分广泛。</li>
</ol>



<h1 id="汇编语言的主要应用场合">汇编语言的主要应用场合</h1>

<ol>
<li>要求<font color="2196f3">执行效率高、反应快</font>的领域，如：操作系统内核，实时系统等； </li>
<li>与硬件资源密切相关的软件开发，如：设备驱动程序等；</li>
<li>大型系统性能的瓶颈，或频繁被使用的子程序或程序段；高级绘图程序、视频游戏程序一般是用汇编语言编写的。</li>
<li>受存储容量限制的应用领域，如：家用电器的计算机控制功能等。</li>
</ol>



<h1 id="学习资源">学习资源</h1>

<ol>
<li><a href="www.asmedu.net">汇编网——王爽《汇编语言》论坛</a></li>
<li><a href="http://www.jingpinke.com/">国家精品课程网——温冬婵《汇编语言》   钱晓捷《32位汇编语言程序设计》</a></li>
</ol>



<h1 id="bcd码">BCD码</h1>

<p>　　<font color="red"><strong>BCD码</strong></font>（Binary Coded Decimal）是一种二－十进制的编码，它使用<font color="blue">4位二进制数</font>表示一位十进制数。最常用的BCD码是<font color="blue">8421码</font>，又叫NBCD码（Natural Binary Coded　Decimal　Code），由于4位二进制数可表示16种状态，只取前10种状态0000-1001来表示十进制数码0-9，从左到右每位二进制数的权分别是8、4、2、1，因此又叫8421码。 <br>
　　例如：十进制数1258对应的BCD码是<code>0001001001011000</code>； <br>
反之，BCD码<code>1001 1000 0111 0010</code>对应的十进制数是9872。 </p>

<p>　　压缩BCD码：用一个字节表达两位BCD码，比如 <code>0100 1001</code>表示<code>49</code>。 <br>
　　非压缩BCD码：将8位二进制的高4位设置为0，仅用低4位表达一位BCD码。比如<code>00000100 00001001</code>表示<code>49</code>。</p>



<h1 id="80x86微处理器">80x86微处理器</h1>

<p>　　80X86是美国Intel公司生产的微处理器系列。 <br>
 　　 <br>
 　　微处理器：把运算器和控制器集成在一个芯片上，构成的中央处理器（CPU）。 <br>
 　　 <br>
 　　微机：即微计算机系统，由微处理器配上存储器、输入输出设备和系统软件等构成。各硬件用系统总线连接在一起。 <br>
 　　 <br>
 　　系统总线包括数据总线（DB）、地址总线(AB)和控制总线(CB)三组。</p>



<h1 id="基于微处理器的计算机系统构成">基于微处理器的计算机系统构成</h1>



<h2 id="数据总线宽度">数据总线宽度</h2>

<p>　　数据总线宽度16位：决定了数据的传输速率。</p>



<h2 id="机器字长16位">机器字长16位</h2>

<p>　　机器字长为16位：可表示数的范围为0000~FFFFH（2^16 = 64K）</p>



<h2 id="地址总线宽度">地址总线宽度</h2>

<p>　　地址总线宽度为20位：寻址空间为2^20 = 1024KB = 1MB</p>



<h1 id="中央处理器">中央处理器</h1>

<p>　　CPU包含了三个部分：<font color="#e91e63">算术逻辑、控制逻辑、寄存器组。</font></p>

<p><img src="http://img.blog.csdn.net/20170522125618149?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>



<h2 id="总线接口部件biu-bus-interface-unit"><span id="biu">总线接口部件BIU （Bus Interface Unit）</span></h2>

<p>　　内部设有四个段地址寄存器,一个指令指针寄存器IP，一个6字节指令队列缓冲器，20位地址加法器和总线控制电路。 <br>
　　 <br>
　　<font color="2196f3"><strong>主要功能</strong></font>：根据执行部件EU的请求，负责从内存单元中预取指令，并将它们送到指令队列缓冲器暂存。即负责完成CPU与存储器或I/O设备之间的数据传送。 </p>



<h2 id="执行部件euexecution-unit">执行部件EU（Execution Unit）</h2>

<p>　　执行部件中包含算术逻辑单元（ALU）、通用寄存器、状态标志寄存器、数据暂存寄存器和执行部件的控制电路。 <br>
　　 <br>
　　<font color="2196f3"><strong>主要功能</strong></font>：从BIU的指令队列中取出指令代码，经指令译码器译码后执行指令所规定的全部功能。执行指令所得结果或执行指令所需的数据，都由EU向BIU发出命令，对存储器或I/O接口进行读/写操作。</p>



<h2 id="寄存器组">寄存器组</h2>

<p><img src="http://img.blog.csdn.net/20170522130400767?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>



<h3 id="数据寄存器">数据寄存器</h3>

<table>
<thead>
<tr>
  <th>名称</th>
  <th>寄存器英文名</th>
  <th>寄存器说明</th>
</tr>
</thead>
<tbody><tr>
  <td>AX</td>
  <td>Accumulator</td>
  <td>累加寄存器，常用于运算；在乘除等指令中指定用来存放操作数，另外，所有的I/O指令都使用这一寄存器与外界设备传送数据。</td>
</tr>
<tr>
  <td>BX</td>
  <td>Base</td>
  <td>基址寄存器，常用于存放存储单元地址。</td>
</tr>
<tr>
  <td>CX</td>
  <td>Count</td>
  <td>计数寄存器，一般作为<strong>循环</strong>或<strong>串</strong>操作等指令中的隐含计数器；常用于保存计算值，如在移位指令，循环(loop)和串处理指令中用作隐含的计数器。</td>
</tr>
<tr>
  <td>DX</td>
  <td>Count</td>
  <td>数据寄存器，常用来存放双字数据的高16位，或存放外设端口地址，比如双字的乘除法。</td>
</tr>
</tbody></table>


<p><font color="2196f3"><strong>共同特点</strong></font>： <br>
　　这四个十六位的寄存器可以分为：</p>

<ul>
<li><strong>高8位</strong>：AH，BH， CH，DH；</li>
<li><strong>低8位</strong>：AL，BL，CL，DL。 <br>
<ul><li>这两组八位寄存器可以分别寻址，并单独使用。</li></ul></li>
</ul>



<h3 id="指针寄存器">指针寄存器</h3>

<table>
<thead>
<tr>
  <th>寄存器名称</th>
  <th>寄存器英文名</th>
  <th>寄存器说明</th>
</tr>
</thead>
<tbody><tr>
  <td>SP</td>
  <td>Stack Pointer</td>
  <td>堆栈指针寄存器。与SS（堆栈段寄存器）配合使用来确定堆栈段栈顶的位置，也就是说SP用于存放栈顶的偏移地址。</td>
</tr>
<tr>
  <td>BP</td>
  <td>Base Pointer</td>
  <td>基址指针寄存器，可用作SS的一个相对基址位置（用于存放堆栈段中某一存储单元的偏移地址。）</td>
</tr>
</tbody></table>


<p>　　<font color="2196f3">说明</font>：指针寄存器和变址寄存器只能按16位进行存取操作，主要用来形成操作数的地址，用于堆栈操作和变址运算中计算操作数的有效地址。</p>



<h3 id="变址寄存器">变址寄存器</h3>

<table>
<thead>
<tr>
  <th>寄存器名称</th>
  <th>寄存器英文名</th>
  <th>寄存器说明</th>
</tr>
</thead>
<tbody><tr>
  <td>SI</td>
  <td>Source Index</td>
  <td>源变址寄存器可用来存放相对于DS段之源变址指针</td>
</tr>
<tr>
  <td>DI</td>
  <td>Destination Index</td>
  <td>目的变址寄存器，可用来存放相对于 ES 段之目的变址指针</td>
</tr>
</tbody></table>


<p><font color="2196f3"><strong>说明：</strong></font></p>

<p>　　SI和DI一般与数据段寄存器DS联合使用，用来确定数据段中某一存储单元的地址。这两个变址寄存器有自动增量和自动减量的功能，所以用来变址是十分方便的。 <br>
　　 <br>
　　在串处理中，SI和DI作为隐含的源变址和目的变址寄存器，此时SI和DI联用，DI和附加段寄存器ES联用，分别达到了在数据段和附加段寻址的目的。 <br>
　　 <br>
　　指针寄存器和变址寄存器只能按16位进行存取操作，主要用来形成操作数的地址，用于堆栈操作和变址运算中计算操作数的有效地址。</p>



<h3 id="指令指针ipinstruction-pointer">指令指针IP(Instruction Pointer)</h3>

<p>　　<strong>指令指针IP</strong>是一个16位专用寄存器(指令指针寄存器)，它指向当前需要取出的指令字节，当<a href="#biu">BIU</a>从内存中取出一个指令字节后，IP就自动加上<font color="red"><strong>指令长度的值</strong></font>，指向下一个指令字节。 <br>
　　 <br>
　　<strong>注意</strong>：IP指向的是指令地址的段内地址偏移量，又称偏移地址(Offset Address)或有效地址(EA，Effective Address)，程序不能直接访问IP。</p>

<p>　　<font color="#9c27b0"><strong>任意时刻，CPU将CS:IP指向的内存单元中的内容看作指令。</strong></font></p>



<h3 id="标志寄存器frflag-register">标志寄存器FR(Flag Register)</h3>

<p>　　8086有一个18位的标志寄存器FR，在FR中有意义的有9位，其中6位是<strong>状态位</strong>，3位是<strong>控制位</strong>。</p>



<h4 id="条件标志">条件标志</h4>

<p>　　状态信息是由中央处理机根据计算结果自动设置的。 </p>

<table>
<thead>
<tr>
  <th>标志名称</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>OF</td>
  <td><strong>溢出标志位OF</strong>(overflow flag)用于反映有符号数加减运算所得结果是否溢出。<br>如果运算结果超过当前运算位数所能表示的范围，则称为<strong>溢出</strong>。<font color="9c27b0">溢出时OF=1，否则OF= 0。</font> <br><font color="red">注意，这里所讲的溢出，只是对有符号数运算而言,对无符号数没有意义。</font></td>
</tr>
<tr>
  <td>SF</td>
  <td><strong>符号标志SF</strong>(sign flag)用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。<font color="9c27b0">正数SF=0,负数SF为1。</font><br><font color="red">注意：SF是对有符号数运算有意义的标志位</font></td>
</tr>
<tr>
  <td>ZF</td>
  <td><strong>零标志ZF</strong>(zero flag)用来反映运算结果是否为0。<font color="9c27b0">如果运算结果为0，则其值为1，否则其值为0。</font>在判断运算结果是否为0时，可使用此标志位。</td>
</tr>
<tr>
  <td>AF</td>
  <td><strong>辅助进位标志AF</strong>(auxiliary flag)<font color="9c27b0">记录运算时第3位(字节运算)或第7位（字运算）产生的进位或借位值。</font>例如，执行加法指令时第3位有进位时AF=1，否则AF=0。</td>
</tr>
<tr>
  <td>PF</td>
  <td><strong>奇偶标志PF</strong>(parity flag)用于反映运算结果中“1”的个数的奇偶性。<font color="9c27b0">当结果操作数中1的个数为偶数时PF=l，否则PF=0。</font></td>
</tr>
<tr>
  <td>CF</td>
  <td><strong>进位标志CF</strong>(carry flag)主要用来反映运算是否产生进位或借位。<font color="9c27b0">当最高有效位有进位或借位时CF=1，否则置CF=0。</font><br><font color="red">注意：CF是对无符号数运算有意义的标志位</font></td>
</tr>
</tbody></table>


<hr>

<p>　　<font color="blue">无符号数比较示例：</font> <br>
　　 <br>
<img src="http://img.blog.csdn.net/20170531195646596?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<hr>



<h4 id="控制标志">控制标志</h4>

<p>　　控制标志是系统程序或用户程序根据需要用指令设置的。</p>

<table>
<thead>
<tr>
  <th>标志名称</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>DF</td>
  <td><strong>方向标志DF</strong>(direction flag)位用来决定在串操作指令执行时有关指针寄存器发生调整的方向。<font color="9c27b0">当DF位为1时，每次操作后使变址寄存器SI和DI减量；当DF为0时，则使SI和DI增量。</font></td>
</tr>
<tr>
  <td>IF</td>
  <td><strong>中断允许标志IF</strong>(interrupt flag)位用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。具体规定如下：<br>(1)当IF=1时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求；<br> (2)当IF=0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求。<br>总的来说：<font color="9c27b0">IF为1时，开中断，否则关中断。</font></td>
</tr>
<tr>
  <td>TF</td>
  <td><strong>跟踪标志TF</strong>(trap flag)， 也叫做陷阱标志。该标志可用于程序调试。TF标志没有专门的指令来设置或清楚。<br>(1)如果TF=1，则CPU处于单步执行指令的工作方式，此时每执行完一条指令，就显示CPU内各个寄存器的当前值及CPU将要执行的下一条指令。<br>(2)如果TF=0，则处于连续工作模式。<br>总的来说：<font color="9c27b0">TF=1时，每条指令执行完后产生陷井，TF=0时，CPU正常工作不产生陷井。</font></td>
</tr>
</tbody></table>




<h3 id="debug中标志位的符号表示">Debug中标志位的符号表示</h3>

<table>
<thead>
<tr>
  <th>标志</th>
  <th>1</th>
  <th>0</th>
</tr>
</thead>
<tbody><tr>
  <td>OF</td>
  <td>OV</td>
  <td>NV</td>
</tr>
<tr>
  <td>DF</td>
  <td>DN</td>
  <td>UP</td>
</tr>
<tr>
  <td>IF</td>
  <td>EI</td>
  <td>DI</td>
</tr>
<tr>
  <td>SF</td>
  <td>NG</td>
  <td>PL</td>
</tr>
<tr>
  <td>ZF</td>
  <td>ZR</td>
  <td>NZ</td>
</tr>
<tr>
  <td>AF</td>
  <td>AC</td>
  <td>NA</td>
</tr>
<tr>
  <td>PF</td>
  <td>PE</td>
  <td>PO</td>
</tr>
<tr>
  <td>CF</td>
  <td>CY</td>
  <td>NC</td>
</tr>
</tbody></table>




<h3 id="标志寄存器flags">标志寄存器FLAGS</h3>

<p>　　这是一个存放条件码标志、控制标志和系统标志的寄存器。</p>



<h3 id="段寄存器segment-register">段寄存器(Segment Register)</h3>

<p>　　为了运用所有的内存空间，8086设定了四个段寄存器，专门用来保存段地址：</p>

<table>
<thead>
<tr>
  <th>名称</th>
  <th align="center">全称</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>CS（Code Segment）</td>
  <td align="center">代码段寄存器</td>
  <td>代码段存放当前正在运行的程序</td>
</tr>
<tr>
  <td>DS（Data Segment）</td>
  <td align="center">数据段寄存器</td>
  <td>数据段存放当前正在运行程序所有的数据，如果程序使用了串处理指令，则其操作数也会存放在数据段中。<br><font color="blue">处理串的时候，DS默认为源串。</font></td>
</tr>
<tr>
  <td>SS（Stack Segment）</td>
  <td align="center">堆栈段寄存器</td>
  <td>定义了堆栈所在的区域。</td>
</tr>
<tr>
  <td>ES（Extra Segment）</td>
  <td align="center">附加段寄存器</td>
  <td>这是一个辅助的数据区，也是串处理指令的目的操作数存放区。<br><font color="blue">处理串的时候，ES默认为目的串。</font></td>
</tr>
</tbody></table>




<h3 id="附录">附录</h3>

<ul>
<li><a href="http://www.cnblogs.com/Zblogs/p/3366727.html">寄存器介绍</a></li>
</ul>



<h1 id="存储器">存储器</h1>

<p>　　存储器是计算机的记忆部件，用来存放程序和数据。按所在的位置，存储器可以分成主存储器和辅助存储器。 <br>
　　 <br>
　　主存储器存放当前正在执行的程序和使用的数据，CPU可以直接存取，它由半导体存储器芯片构成，其成本高，容量小，但速度快。 <br>
　　 <br>
　　辅助存储器可用来长期保存大量程序和数据,CPU需要通过I/O接口访问，它由磁盘或光盘构成，其成本低，容量大，但速度较慢。</p>



<h2 id="存储单元">存储单元</h2>

<p>　　存储器被划分为若干个存储单元，每个存储单元有一个惟一的存储器地址，从0开始顺序编号,存储单元的地址是无符号数, n位二进制数共能表示2^n个存储单元的地址。</p>



<h3 id="类型">类型</h3>

<table>
<thead>
<tr>
  <th>Name</th>
  <th align="center">全称</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>DB</td>
  <td align="center">define byte</td>
  <td>定义字节类型变量，一个字节数据占1个字节单元，读完一个，偏移量加1</td>
</tr>
<tr>
  <td>BW</td>
  <td align="center">define word</td>
  <td>定义字类型变量，一个字数据占2个字节单元，读完一个，偏移量加2</td>
</tr>
<tr>
  <td>DD</td>
  <td align="center">define double(word)</td>
  <td>定义双字类型变量，一个双字数据占4个字节单元，读完一个，偏移量加4</td>
</tr>
</tbody></table>




<h3 id="字地址">字地址</h3>

<p>　　<strong>字地址</strong>：一个字存放到存储器要占用连续的两个字节单元。字的低字节（低8位）存放在低地址中，高字节（高8位）存放在高地址中，字单元的地址用低地址表示。 <br>
　　例如：34560H的字单元的内容是1234H，而地址为78780H时字单元的内容是3332H。记作： <br>
 <img src="http://img.blog.csdn.net/20170522143049595?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<ul>
<li>（34560H）=1234H</li>
<li><p>（78780H）= 3332H</p>

<p>　　同一个地址既可以看成字节单元，也可以看作是<font color="2196f3">字单元、双字单元、或者是4字单元的地址</font>，这要根据使用情况而定。字单元地址可以是偶数，也可以是奇数。但是，在8086和80286中，访问存储器（要求取数或者存数）都是以字为单元进行的，也就是说，机器是以<font color="2196f3"><strong>偶地址</strong></font>访问存储器的。这样，对于<font color="2196f3"><strong>奇地址</strong></font>的字单元，要取一个字需要访问二次存储器，当然，这样做需要花费较多的时间。</p>

<p>　　存储器有这样一个特性：它的内容取之不尽的。也就是说，<font color="9c27b0"><strong>从某个单元取出其内容后，该单元仍然保持着原来的内容不变，可以重复取出，只有存入新的信息后，原来保存的内容就自动丢失了。</strong></font></p></li>
</ul>



<h2 id="各类存储器芯片">各类存储器芯片</h2>

<p>　　从读写属性上看分为两类：</p>

<ul>
<li>随机存储器（RAM）和只读存储器（ROM）</li>
<li>从功能和连接上分类： <br>
<ul><li>随机存储器RAM</li>
<li>装有BIOS的ROM</li>
<li>接口卡上的RAM</li></ul></li>
</ul>

<hr>

<p>　　所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器；每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间；CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。</p>

<p><img src="http://img.blog.csdn.net/20170522142509523?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>



<h2 id="寄存器与存储器的比较">寄存器与存储器的比较</h2>

<p><img src="http://img.blog.csdn.net/20170522143719552?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>



<h2 id="实模式存储器寻址">实模式存储器寻址</h2>

<p>　　8086CPU的地址线是20位的，这样最大可寻址空间应为220=1MB，其物理地址范围从00000H～FFFFFH。 <br>
　　 <br>
　　而8086CPU寄存器都是16位的，仅能表示地址范围  0000H ~ FFFFH(64KB) 。那么，这1MB(2^20)空间如何用16位寄存器表达呢？ <br>
　　 <br>
　　根据要求可把1M字节地址空间划成若干逻辑段。每个逻辑段必须满足两个条件： <br>
　　 <br>
　　（1）逻辑段的起始地址（简称段首址）必须是<strong>16的倍数</strong>； <br>
　　（2）逻辑段的最大长度为<strong>64K</strong>(2^6)。 <br>
　　 <br>
　　按照这两个条件，1M字节地址空间最多可划分成64K个逻辑段，最少也要划分成16个逻辑段。逻辑段与逻辑段可以相连，也可以不连，还可以重叠。</p>



<h2 id="逻辑地址la和物理地址pa">逻辑地址（LA）和物理地址（PA）</h2>



<h3 id="物理地址">物理地址</h3>

<p>　　就是存储器的实际地址，它是指CPU和存储器进行数据交换时所使用的地址（20位）。</p>



<h3 id="逻辑地址">逻辑地址</h3>

<p>　　是在程序中使用的地址（16位） ，它由段地址和偏移地址两部分组成。逻辑地址的表示形式为<font color="2196f3">“段地址∶偏移地址”。</font></p>

<ul>
<li><strong>段地址</strong>：是指逻辑段在主存中的起始位置。</li>
<li><strong>段内偏移地址</strong>：是指主存单元距离段首址的偏移量，简称偏移地址，用EA来表示，由于限定每段不超过64KB，所以偏移地址可以用16位数据表示。</li>
<li><strong>物理地址形成</strong>：物理地址用PA表示, 将逻辑地址中的段地址左移4位，加上偏移地址就得到20位物理地址。 <br>
<ul><li><font color="2196f3">物理地址 = 段地址 x 16 + 偏移地址</font></li></ul></li>
</ul>



<h3 id="段的概念">段的概念</h3>

<p><font color="red"><strong>错误认识：</strong></font> <br>
　　内存被划分成了一个一个的段，每一个段有一个段地址。 <br>
<font color="9c27b0"><strong>正确认识：</strong></font> <br>
　　内存并没有分段，段的划分来自于CPU，由于8086CPU用“<font color="2196f3">（段地址×16）+偏移地址=物理地址</font>”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。</p>



<h2 id="8086pc工作过程的简要描述">8086PC工作过程的简要描述</h2>

<ul>
<li>1）从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器；</li>
<li>2）IP = IP + 所读取指令的长度，从而指向下一条指令；</li>
<li>3）执行指令。 转到步骤 （1），重复这个过程。</li>
<li>在 8086CPU 加电启动或复位后（ 即 CPU刚开始工作时）CS和IP被设置为<font color="2196f3">CS=FFFFH，IP=0000H</font>，即在8086PC机刚启动时，CPU从内存<font color="2196f3">FFFF0H</font>单元中读取指令执行，<font color="2196f3">FFFF0H</font>单元中的指令是8086PC机开机后执行的第一条指令。</li>
</ul>



<h1 id="汇编指令">汇编指令</h1>



<h2 id="指令格式">指令格式</h2>

<ul>
<li>ASMARM的专栏 - <a href="http://blog.csdn.net/asmarm/article/details/28966165"> 浅谈ARM 汇编中的标号（Labels） </a></li>
</ul>



<h3 id="1双操作数指令二地址指令">1、双操作数指令（二地址指令）</h3>

<ul>
<li>格式：[标号：] 操作符　DST，SRC　[；注释]</li>
<li>操作规定： <br>
<ul><li>1）DST与SRC应为同种操作类型且类型明确，即同为字节类型或字类型。</li>
<li>2）DST不能是立即数。</li>
<li>3）SRC和DST不能同时为存储器操作数(mem) 。</li>
<li>4）操作结束后，运算结果存入DST中，SRC内容不变。</li></ul></li>
<li>例如：</li>
</ul>



<pre class="prettyprint"><code class="language-asm hljs avrasm"><span class="hljs-keyword">MOV</span> AX,BX <span class="hljs-comment">;将BX寄存器中的16位数送到AX寄存器。</span>
<span class="hljs-keyword">MOV</span> AX,BL <span class="hljs-comment">;这句话是错误的</span></code></pre>



<h3 id="2单操作数指令一地址指令">2、单操作数指令（一地址指令）</h3>

<ul>
<li>格式：[标号：] 操作符　DST　[；注释]</li>
<li>操作规定： <br>
<ul><li>1）DST类型必须明确即为字节类型或字类型，不能是模糊类型</li>
<li>2）操作对象为目的操作数，操作结束后结果存入DST中</li>
<li>3）DST不能是立即数，只能是寄存器操作数(reg) 或存储器操作数(mem)。</li></ul></li>
</ul>



<pre class="prettyprint"><code class="language-asm hljs avrasm"><span class="hljs-keyword">DEC</span> CX <span class="hljs-comment">;将计数器CX的内容减1 。</span></code></pre>



<h3 id="3无操作数指令零地址指令">3、无操作数指令（零地址指令）</h3>

<ul>
<li>格式：[标号：] 操作符　[；注释]</li>
<li>操作规定：指令中只有操作码，不含操作数，这种指令有两种可能： <br>
<ul><li>1）无需任何操作数。如停机指令（HLT）、空操作指令（NOP）等。</li>
<li>2）所需操作数是隐含指定的，操作时取固定操作数进行操作。如进位位置0（CLC）、方向标志置0（CLD）。 </li></ul></li>
</ul>



<h2 id="寻址方式">寻址方式</h2>

<p>　　定义：<font color="blue">寻址方式是指寻找指令中操作数所在地址的方法</font>。  <br>
　　常用的寻址方式有：<font color="blue">立即寻址、直接寻址、寄存器寻址、寄存器间接寻址、变址寻址、基址加变址、隐含寻址等</font>。 <br>
　　寻找指令中所需要操作数存放地址的方式或者程序转移时寻找转移地址的方式称为寻址方式，因而寻址方式有两大类：一类是数据寻址方式，另一类是转移地址寻址方式。 <br>
　　由于80x86指令涉及四种操作数：<font color="2196f3">立即操作数(data)、寄存器操作数(reg)、存储器操作数(mem)和隐含操作数</font>，因此，数据寻址方式又可对应四种寻址方式，即：<font color="2196f3">立即寻址、寄存器寻址、存储器寻址和固定寻址。</font>  </p>



<h3 id="数据寻址方式-立即寻址">数据寻址方式-立即寻址</h3>

<p>　　操作数直接包含在指令中，它紧跟在指令操作码后面，它作为指令存放在存储器代码段中，这种操作数称为<font color="blue">立即数</font>。立即数可以是8位，也可以是16位。</p>



<pre class="prettyprint"><code class="language-asm hljs fix"><span class="hljs-attribute">MOV  AX，1234H ;(AX)</span>=<span class="hljs-string">1234H</span></code></pre>

<p>　　立即寻址方式用来表示<font color="blue">常数</font>，它常用于给寄存器或内存单元赋初值。需要强调的是，<font color="red">立即寻址只能用于源操作数，不能用于目的操作数，且源操作数的长度应该与目的操作数的长度一致。</font></p>



<h3 id="数据寻址方式-寄存器寻址">数据寻址方式-寄存器寻址</h3>

<p>　　操作数直接存放在由指令指明的寄存器中。在汇编指令中直接书写寄存器名，16位寄存器操作数可以是AX、BX、CX、DX、SI、DI、BP、SP、DS、ES、SS、CS等；8位寄存器操作数只能是AH、AL、BH、BL、CH、CL、DH、DL。 <br>
　　<font color="9c27b0">指令指针寄存器IP和标志寄存器FLAGS一般不直接出现在程序中。</font> <br>
　　此寻址方式由于存取操作数直接从CPU内部寄存器中获得，不需访问存储器，因而指令执行的速度快。 <br>
　　 寄存器寻址既可用于<font color="9c27b0">源操作数</font>，又可用于<font color="9c27b0">目的操作数</font>，应用频率最高。 <br>
　　<strong>注意：</strong><font color="red">CS不能作为目的操作数，因为CS:IP控制着程序指令序列的执行顺序，不能在程序中由指令随意改变。</font></p>



<h3 id="数据寻址方式-存储器寻址">数据寻址方式-存储器寻址</h3>

<p>　　存储器寻址方式的操作数都是存放在除代码段以外的存储区中，一般是数据段、附加段、堆栈段中的存储单元。指令中给出的是<font color="blue">存储单元的地址</font>或产生存储单元地址的表达式。 <br>
　　在汇编语言源程序中，存储单元地址是采用逻辑地址的形式表示的，即：<font color="blue">段首址：段内偏移地址</font>。段首址存放在某个段寄存器中，<font color="red">段内偏移地址即有效地址</font><font color="blue">EA</font>是由3个地址分量的某种组合求得，这3个地址分量是：位移量、基址（BX,BP）、变址(SI,DI) 。 <br>
　　这3个地址分量的不同组合，使形成有效地址EA的方法不同，相应有以下5种不同的存储器操作数寻址方式：<font color="blue">直接寻址、寄存器间接寻址、寄存器相对寻址、基址变址寻址、相对基址变址寻址。</font></p>



<h4 id="直接寻址方式">直接寻址方式</h4>

<p>　　直接寻址是最简单的存储器寻址，操作数的有效地址<font color="blue">EA</font>由指令直接给出，只包含位移量。它主要用于存取简单变量。</p>



<pre class="prettyprint"><code class="language-asm hljs css"><span class="hljs-tag">MOV</span> <span class="hljs-tag">AX</span>, <span class="hljs-attr_selector">[2000H]</span></code></pre>

<p>　　EA=2000H, 假设(DS)=3000H, 那么PA=32000H <br>
<img src="http://img.blog.csdn.net/20170523211127650?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<p>　　<font color="blue">对使用直接寻址方式需说明以下几点：</font></p>

<ul>
<li>操作数默认隐含的段为数据段 DS。</li>
<li>若操作数在代码段、堆栈段或附加段中，可使用段跨越前缀 。<code>MOV  AX, ES: [2000H]</code> </li>
<li>指令中操作数的EA既可以是一个数字地址，也可以是一个符号地址。当EA是一个数字时，一定要注意立即寻址方式与直接寻址方式的区别，直接寻址必须有[ ]符号。</li>
<li>操作数地址可由变量（符号地址）表示,  但要注意变量的属性。</li>
</ul>



<pre class="prettyprint"><code class="language-asm hljs avrasm">VALUE DB <span class="hljs-number">10</span>
<span class="hljs-keyword">MOV</span> AH, VALUE   
<span class="hljs-keyword">MOV</span> AX, VALUE  
<span class="hljs-keyword">MOV</span> AX, WORD PTR VALUE </code></pre>

<p>　　直接寻址方式适合于处理存储器的单个存储单元。例如，要处理某个存放在存储器里面的变量，可以使用直接寻址方式把变量先取到一个寄存器中，然后在进一步处理。 <br>
　　<font color="red">80x86中</font>，为了使指令字不要太长，规定双操作数指令的两个操作数中，<font color="red">只能有一个使用存储器寻址方式</font>，这就是一个变量常常先要送到寄存器的原因了。 <br>
　　</p>

<h4 id="寄存器间接寻址">寄存器间接寻址</h4>

<p>　　 <br>
　　操作数的有效地址只包含基址寄存器或者变址寄存器内容的一种成分。因此，有效地址就在某个寄存器中，而操作数则在存储器中。 <br>
　　操作数的<font color="blue">有效地址EA</font>存放在<font color="blue">SI、DI、BX或BP</font>之一中，而操作数在存储器中。若用<font color="blue">BX、SI或DI</font>间接寻址时，则操作数默认在数据段中，用DS的内容作为段首址，操作数的物理地址为： <br>
<img src="http://img.blog.csdn.net/20170523212022508?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br>
　　若指令中使用BP间接寻址时，则用堆栈段SS的内容作为段首址，操作数的物理地址为：　<font color="blue">PA＝（SS）×16 ＋（BP）</font>。</p>



<pre class="prettyprint"><code class="language-asm hljs avrasm"><span class="hljs-keyword">MOV</span>   AX, [BX]    <span class="hljs-comment">;PA = 16d x (DS) + (BX)</span>
<span class="hljs-keyword">MOV</span>   AX, ES:[BX] <span class="hljs-comment">;PA = 16d x (ES) + (BX)，在这里，ES称为段跨越前缀</span>
<span class="hljs-keyword">MOV</span>   AX, [BP]    <span class="hljs-comment">;PA = 16d x (SS) + (BP)</span></code></pre>

<p><font color="red">注意：</font></p>

<ul>
<li>8086不允许使用AX、CX、DX 来存放 EA，比如：<code>MOV AX, [CX]</code>就是错误的。</li>
<li>SRC 和 DST 的字长一致，自动适应寄存器的长度。 </li>
</ul>

<pre class="prettyprint"><code class="language-asm hljs css"><span class="hljs-tag">MOV</span> <span class="hljs-tag">DL</span>, <span class="hljs-attr_selector">[ BX ]</span> ; <span class="hljs-attr_selector">[BX]</span>指示一个字节单元
<span class="hljs-tag">MOV</span> <span class="hljs-tag">DX</span>, <span class="hljs-attr_selector">[ BX ]</span> ; <span class="hljs-attr_selector">[BX]</span>指示一个字单元</code></pre>

<ul>
<li>适用于数组、字符串、表格的处理（可以看成一个数组来使用），执行完一条指令后，只需修改寄存器内容就可以取出下一项处理。</li>
</ul>

<h4 id="寄存器相对寻址方式">寄存器相对寻址方式</h4>

<p>　　寄存器相对寻址方式也可以称为<font color="blue">直接变址寻址方式</font>。 <br>
　　操作数的有效地址EA是指令中指定的基址寄存器或变址寄存器的内容与指令中给出的位移量之和，即 <br>
<img src="http://img.blog.csdn.net/20170523213207226?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br>
　　操作数的物理地址为： <br>
<img src="http://img.blog.csdn.net/20170523213428493?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br>
　　若操作数不在默认段中，则应使用段跨越前缀明确指定。  </p>



<pre class="prettyprint"><code class="language-asm hljs css"><span class="hljs-tag">MOV</span>    <span class="hljs-tag">AX</span>,  <span class="hljs-tag">COUNT</span><span class="hljs-attr_selector">[SI]</span> 
<span class="hljs-tag">MOV</span>    <span class="hljs-tag">AX</span>,  <span class="hljs-attr_selector">[COUNT+SI]</span></code></pre>

<ul>
<li><font color="blue">适于数组、字符串、表格的处理。</font></li>
</ul>

<h4 id="基址变址寻址">基址变址寻址</h4>

<p>　　操作数的<font color="blue">有效地址EA</font>是指令中的基址寄存器的内容+变址寄存器的内容。 <br>
　　指令格式： <br>
　　<img src="http://img.blog.csdn.net/20170523214659326?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>



<pre class="prettyprint"><code class="language-asm hljs markdown">MOV AX, [<span class="hljs-link_label">BX</span>][<span class="hljs-link_reference">DI</span>]
等价于
MOV AX, [BX+DI]

MOV AX, ES:[<span class="hljs-link_label">BX</span>][<span class="hljs-link_reference">SI</span>]</code></pre>

<ul>
<li>适于数组、字符串、表格的处理</li>
<li>必须是一个基址寄存器和一个变址寄存器的组合</li>
</ul>

<h4 id="相对基址变址寻址">相对基址变址寻址</h4>

<p>　　操作数的有效地址EA是指令中的基址寄存器的内容、变址寄存器的内容、位移量三个地址分量之和，即： <br>
　　<img src="http://img.blog.csdn.net/20170523215017905?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br>
　　<font color="red"><strong>相对基址加变址寻址方式有多种等价的书写方式</strong></font>，书写格式：<code>[BX+SI+1000H]、1000H[BX+SI]、1000H[BX][SI]和1000H[SI][BX]</code>等格式都是正确的，并且其寻址含义也是一致的，但格式：<code>BX[1000H+SI]、SI[1000H+BX]</code>等是错误的，即所用寄存器不能在”[“，”]”之外，该限制对寄存器相对寻址方式的书写也同样起作用。</p>



<pre class="prettyprint"><code class="language-asm hljs scss">MOV    AX,  <span class="hljs-attribute">MASK</span> <span class="hljs-attr_selector">[BX]</span> <span class="hljs-attr_selector">[SI]</span>
或
MOV    AX,  <span class="hljs-attribute">MASK</span> <span class="hljs-attr_selector">[BX+SI]</span>
或
MOV    AX,  <span class="hljs-attr_selector">[MASK+BX+SI]</span> </code></pre>

<p>　　这种寻址方式通常用于对二维数组的寻址。例如，存储器中存放着由多个记录组成的文件，则位移量可指向文件之首，基址寄存器指向某个记录，变址寄存器则指向该记录中的一个元素。这种寻址方式也为堆栈处理提供了方便，一般（BP）可指向栈顶，从栈顶到数组的首地址可以使用位移量来表示，变址寄存器可以用来访问数组中的某个元素。</p>

<h3 id="附录-1">附录</h3>

<p>　　可以出现在<code>[]</code>中的内容是有限制的，他们必须是下列中的一个（其中idata表示一个立即数）：</p>



<pre class="prettyprint"><code class="language-asm hljs ">idata
BX
BP
SI
DI
BX+SI
BX+DI
BP+SI
BP+DI
BX+idata
BP+idata
SI+idata
DI+idata
BX+SI+idata
BX+DI+idata
BP+SI+idata
BP+DI+idata</code></pre>

<p>　　其中，使用到BP的默认段寄存器为SS,其他未DS</p>

<h2 id="段寄存器的使用规定">段寄存器的使用规定</h2>

<p><img src="http://img.blog.csdn.net/20170523220543320?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>



<h1 id="汇编语言源程序">汇编语言源程序</h1>

<p><img src="http://img.blog.csdn.net/20170524135955504?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<ul>
<li>汇编源程序：由三部分组成：汇编指令、伪指令、其他标号与符号。 <br>
<ul><li>指令是能被计算机识别并执行的二进制代码，它规定了计算机能完成的某一操作。</li>
<li><font color="blue">伪指令</font>是对汇编<font color="blue">起某种控制作用</font>的特殊命令，其格式与通常的操作指令一样，并加在汇编程序的任何地方，但是他们<font color="blue">并不产生机器指令</font>。</li></ul></li>
<li>一个汇编源程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。</li>
<li>注意：一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。</li>
</ul>



<h2 id="处理器选择伪操作">处理器选择伪操作</h2>

<table>
<thead>
<tr>
  <th>伪操作</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>.8086</td>
  <td>选择8086指令系统</td>
</tr>
<tr>
  <td>.286</td>
  <td>选择80286指令系统</td>
</tr>
<tr>
  <td>.286 P</td>
  <td>选择保护模式下的80286指令系统</td>
</tr>
<tr>
  <td>.386</td>
  <td>选择80386指令系统</td>
</tr>
<tr>
  <td>.386 P</td>
  <td>选择保护模式下的80386指令系统</td>
</tr>
<tr>
  <td>.486</td>
  <td>选择80486指令系统</td>
</tr>
<tr>
  <td>.486 P</td>
  <td>选择保护模式下的80486指令系统</td>
</tr>
<tr>
  <td>.586</td>
  <td>选择80586指令系统</td>
</tr>
<tr>
  <td>.586 P</td>
  <td>选择保护模式下的80586指令系统</td>
</tr>
</tbody></table>


<p>　　这类伪操作一般都是放在整个程序的最前面。如果不给出，则汇编程序一般认为其默认值为.8086。</p>



<h2 id="段定义伪操作">段定义伪操作</h2>

<p>　　在段定义时，如果定位类型用户未选择，就表示是隐含类型，其隐含类型是<font color="blue">PARA</font>。 <br>
　　 <br>
　　<font color="blue">PARA</font>属定位类型，是对该段起始地址定位。一般，各个逻辑段的首地址在‘节’的整数边界上（每16个存储单元叫做一节），即每个逻辑段的起始地址是16的整数倍。对于PARA—指定定位段的起始地址必须在节的整数边界。</p>

<p>　　存储器的物理地址是由段地址和偏移地址组合而成的，汇编程序在把源程序转换为目标程序的时候，必须确定标号和变量（代码段和数据段的符号地址）的偏移地址，并且需要把有关信息通过目标模块传送给连接程序，以便连接程序把不同的段和模块连接起来，形成一个可执行的程序。 <br>
    明确段与寄存器的关系：<code>assume cs:code, ds:data, es:extra</code></p>



<pre class="prettyprint"><code class="language-asm hljs haskell"><span class="hljs-typedef"><span class="hljs-keyword">data</span>   segment         ; 定义数据段</span>
       …
<span class="hljs-typedef"><span class="hljs-keyword">data</span>   ends</span>
;<span class="hljs-comment">----------------------------------------</span>
<span class="hljs-title">extra</span>  segment         ; 定义附加段
       …
<span class="hljs-title">extra</span>  ends
;<span class="hljs-comment">----------------------------------------</span>
<span class="hljs-title">code</span>   segment         ; 定义代码段，其中的段寄存器名必须是<span class="hljs-type">CS</span>、<span class="hljs-type">ES</span>、<span class="hljs-type">DS</span>、<span class="hljs-type">SS</span>（对于<span class="hljs-number">386</span>及其后继机型还有<span class="hljs-type">FS</span>和<span class="hljs-type">GS</span>）中的一个。
       assume cs:code, ds:<span class="hljs-typedef"><span class="hljs-keyword">data</span>, es:extra</span>
<span class="hljs-title">start</span>: ;<span class="hljs-comment">----------------------程序开始的标号</span>
       mov   ax, <span class="hljs-typedef"><span class="hljs-keyword">data</span></span>
       mov   ds, ax    ; 段地址 -&gt; 段寄存器
       …
       mov   ax,<span class="hljs-number">4</span>c00h
       int   <span class="hljs-number">21</span>h
<span class="hljs-title">code</span>   ends
       end   start ;<span class="hljs-comment">------------程序结束标志</span>
</code></pre>

<p>说明：</p>

<ul>
<li>1)data为段名称，也是段首地址，可自己定义 <br>
<ul><li>功能：定义一个段，segment说明一个段开始，ends 说明一个段结束。一个段必须有一个名称来标识，使用格式为： <br>
<ul><li>段名 segment</li>
<li>段名 ends</li></ul></li></ul></li>
<li>2)明确段和段寄存器的关系。<code>assume</code>只是说明关联关系，并没有对段寄存器赋值，除了CS（装入程序时由CPU给出），其他段寄存器要在程序中设置。</li>
<li>3)<code>mov ax,4c00h</code>和<code>int 21h</code>最后两条指令所实现的功能是程序返回。</li>
<li>4)程序结束标志，格式：<code>END [label]</code>,标号label 指示程序开始执行的起始地址。</li>
</ul>



<h2 id="伪操作伪指令">伪操作（伪指令）</h2>

<p>　　伪操作是汇编程序对源程序进行汇编时处理的操作，完成处理器选择、存储模式定义、数据定义、存储器分配、指示程序开始结束等功能。</p>

<ul>
<li>处理器选择伪操作； <br>
<ul><li>功能：告诉汇编程序应该选择哪一种指令系统。 <br>
位置：一般放在整个程序的最前面，也可放在程序中所用指令的上一行。 <br>
如不给出，则默认为.8086。</li></ul></li>
<li>段定义伪操作；</li>
<li>程序开始和结束伪操作； <br>
<ul><li>Start</li>
<li>end Start</li></ul></li>
<li>数据定义及存储器分配伪操作；</li>
<li>表达式赋值伪操作；</li>
<li>地址计数器与对准伪操作；</li>
<li>基数控制伪操作。</li>
</ul>



<h3 id="数据定义和存储器分配伪操作">数据定义和存储器分配伪操作</h3>

<p>格式：<font color="red">[变量]   助记符   操作数 [ , 操作数 , … ]  [ ; 注释] </font></p>

<ul>
<li>助记符：<font color="green">DB DW DD DF DQ DT</font></li>
<li>例：<font color="e91e63">操作数可以是常数或表达式</font> <br>
<ul><li><code>DATA_BYTE  DB  10,4,10H,?</code></li>
<li><code>DATA_WORD  DW  100,100H,-5,?</code></li>
<li>汇编程序在汇编期间在存储器中存入数据</li></ul></li>
</ul>

<p><img src="http://img.blog.csdn.net/20170525202013550?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<ul>
<li>操作数也可以是字符串</li>
</ul>



<pre class="prettyprint"><code class="language-asm hljs php"><span class="hljs-keyword">ARRAY</span>  DB  ‘HELLO’
       DB  ‘AB’
       DW  ‘AB’     </code></pre>

<p><img src="http://img.blog.csdn.net/20170525202135567?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<ul>
<li>操作数也可以是地址 </li>
</ul>

<pre class="prettyprint"><code class="language-asm hljs ">      PAR1  DW  100,200
      PAR2  DW  300,400
ADDR_TABLE  DW  PAR1,PAR2</code></pre>

<ul>
<li>操作数字段还可以使用<font color="blue">复制操作符DUP</font>来复制操作数 <br>
<ul><li><code>repeat_count DUP(operand,……,operand)</code></li>
<li><font color="blue">repeat_count</font>可以是一个表达式，它的值应该是一个正整数，用来指定括号中的操作数的重复次数。</li></ul></li>
<li>操作数？可以保留存储空间，但是不存入数据。（仅仅申请一个存储空间）</li>
</ul>

<pre class="prettyprint"><code class="language-asm hljs php"><span class="hljs-keyword">VAR</span>  DB <span class="hljs-number">100</span> DUP (?) ; 这里表示申请<span class="hljs-number">100</span>个字单元大小的内存空间，但是不进行初始化
     DB <span class="hljs-number">2</span> DUP (<span class="hljs-number">0</span>,<span class="hljs-number">2</span> DUP(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),<span class="hljs-number">3</span>) ; 把<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>按字单元存放<span class="hljs-number">2</span>次。</code></pre>

<pre class="prettyprint"><code class="language-asm hljs avrasm">OPER1  DB  ?, ?
OPER2  DW  ?, ?
       ……
       <span class="hljs-keyword">MOV</span>  OPER1, <span class="hljs-number">0</span>   <span class="hljs-comment">;字节指令</span>
       <span class="hljs-keyword">MOV</span>  OPER2, <span class="hljs-number">0</span>   <span class="hljs-comment">;字指令</span>

OPER1  DB  <span class="hljs-number">1</span>, <span class="hljs-number">2</span>
OPER2  DW  <span class="hljs-number">1234</span>H, <span class="hljs-number">5678</span>H
       ……
       <span class="hljs-keyword">MOV</span>  AX, OPER1+<span class="hljs-number">1</span>  ×
       <span class="hljs-keyword">MOV</span>  AL, OPER2    ×  类型不匹配

    <span class="hljs-keyword">MOV</span>  AX, WORD PTR  OPER1+<span class="hljs-number">1</span>
    <span class="hljs-keyword">MOV</span>  AL, BYTE PTR  OPER2
</code></pre>

<ul>
<li><code>(AX)=3402H    (AL)=34H</code></li>
<li><font color="e91e63">可以看出：同一个变量可以具有不同的类型属性。</font></li>
</ul>

<h4 id="label-伪操作-name-label-type">LABEL 伪操作：  name  LABEL  type</h4>

<ul>
<li><font color="e91e63">LABEL可以使同一个变量具有不同的类型属性。</font></li>
</ul>



<pre class="prettyprint"><code class="language-asm hljs vhdl">　　变量名   <span class="hljs-keyword">LABEL</span>   类型 
<span class="hljs-keyword">or</span>　标号   　<span class="hljs-keyword">LABEL</span>   类型 </code></pre>

<p>　　其中变量的数据类型可以是BYTE，WORD，DWORD，标号的代码类型可以是NEAR或FAR。  <br>
　　 <br>
　　数据定义及存储器分配伪指令格式中的 “变量 “是操作数的符号地址，它是可有可无 的，它的作用与指令语句前的标号相同，区别是变量后面不加冒号。如果语句中有变量，那么汇编程序将操作数的第一个字节的偏移地址赋于这个变量。 </p>

<pre class="prettyprint"><code class="language-asm hljs ruleslanguage">BYTE_ARRAY  <span class="hljs-keyword">LABEL</span>  BYTE
WORD_ARRAY  DW  <span class="hljs-number">50</span>  DUP (?)
       tos  <span class="hljs-keyword">LABEL</span>  WORD</code></pre>

<h3 id="表达式赋值伪操作">表达式赋值伪操作</h3>

<p>　　说明：有时程序中多次出现同一个表达式，为了方便起见，可以使用赋值伪操作给表达式赋予一个名字。、 <br>
　　<font color="blue">EQU是赋值伪指令。赋值语句仅在汇编源程序时，作为替代符号用。不产生目标代码，也不占有存储单元。</font> <br>
　　此后，程序中凡是用到该表达式之处，都可以用表达式名来代替了。可见，EQU的引入提高了程序的可读性，也使其更加易于修改。 <br>
　　 <br>
　　格式：表达式名 <font color="red">EQU</font> 表达式 <br>
　　 <br>
　　功能：给表达式赋予一个名字，在程序中用表达式名代替该表达式。</p>



<pre class="prettyprint"><code class="language-asm hljs dos">ALPHA   <span class="hljs-flow">EQU</span>  <span class="hljs-number">9</span>
BETA    <span class="hljs-flow">EQU</span>  ALPHA+<span class="hljs-number">18</span>
BB      <span class="hljs-flow">EQU</span>  [BP+<span class="hljs-number">8</span>]</code></pre>

<p>　　<font color="blue">“ = ” 伪操作 （允许重复定义）</font></p>

<pre class="prettyprint"><code class="language-asm hljs makefile">……
<span class="hljs-constant">EMP</span> = 7
……
<span class="hljs-constant">EMP</span> = EMP+1
……</code></pre>

<p>　　<font color="red">说明：</font>EQU指令类似于C语言的#define宏，在编译前被转化。</p>

<h3 id="地址计数器与org伪操作">地址计数器与ORG伪操作</h3>



<h4 id="地址计数器">地址计数器$</h4>

<p>　　 <br>
　　地址计数器 <font color="red">$</font>：保存当前正在汇编的指令的偏移地址</p>



<pre class="prettyprint"><code class="language-asm hljs ruby"><span class="hljs-constant">JNE</span>  <span class="hljs-variable">$+</span><span class="hljs-number">6</span>    ; 转向地址是 <span class="hljs-constant">JNE</span> 的首址 +<span class="hljs-number">6</span>
<span class="hljs-constant">JMP</span>  <span class="hljs-variable">$+</span><span class="hljs-number">2</span>    ; 转向下一条指令</code></pre>

<ul>
<li><font color="blue">$ 用在指令中时，表示本条指令的第一个字节的地址；</font></li>
<li><font color="blue">$ 用在伪操作的参数字段时表示地址计数器的当前值。</font>         </li>
<li>例如：<code>ARRAY   DW   1, 2 , $+4 , 3 , 4 , $+4</code></li>
<li><img src="http://img.blog.csdn.net/20170525204938284?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br>
<ul><li>通过图片可以看出，地址0078保存的数据为当前地址加上4；</li>
<li>地址007E是当前地址加上4。</li></ul></li>
</ul>

<h4 id="org">ORG</h4>

<p>　　<font color="red">ORG</font> 伪操作：用来设置当前地址计数器的值。即：<font color="blue">指定一个地址，后面的程序或数据从这个地址值开始分配。</font></p>



<pre class="prettyprint"><code class="language-asm hljs ruby"><span class="hljs-constant">SEG1</span>    <span class="hljs-constant">SEGMENT</span>
        <span class="hljs-constant">ORG</span>   <span class="hljs-number">10</span>
        <span class="hljs-constant">VAR1</span>  <span class="hljs-constant">DW</span>  <span class="hljs-number">1234</span>H
        <span class="hljs-constant">ORG</span>   <span class="hljs-number">20</span>
        <span class="hljs-constant">VAR2</span>  <span class="hljs-constant">DW</span>  <span class="hljs-number">5678</span>H
        <span class="hljs-constant">ORG</span>   <span class="hljs-variable">$+</span><span class="hljs-number">8</span>; 当前地址加<span class="hljs-number">8</span>，
        <span class="hljs-constant">VAR3</span>  <span class="hljs-constant">DW</span>  <span class="hljs-number">1357</span>H
<span class="hljs-constant">SEG1</span>    <span class="hljs-constant">ENDS</span></code></pre>

<p><img src="http://img.blog.csdn.net/20170525211043091?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<h3 id="even">EVEN</h3>

<p>　　EVEN伪操作使下一个变量或者指令开始于偶数字节地址。一个字的地址最好从偶地址开始，所以对于字数组为了保证其从偶地址开始，可以在其前面使用EVEN伪操作来达到这一目的。</p>

<p>　　EVEN        ;使下一地址从偶地址开始</p>



<pre class="prettyprint"><code class="language-asm hljs autohotkey"><span class="hljs-literal">A</span>  DB  ‘morning’
EVEN  <span class="hljs-comment">;使下一地址从偶地址开始</span>
B  DW  <span class="hljs-number">2</span>  DUP  (?) </code></pre>

<p><img src="http://img.blog.csdn.net/20170525211234686?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<h3 id="align">ALIGN</h3>

<p>　　ALIGN伪操作为保证双字数组边界从4的倍数开始创造了条件：</p>



<pre class="prettyprint"><code class=" hljs ">ALIGN  4     ; 保证下一个地址是4的倍数
ALIGN  2     ; 与EVEN等价</code></pre>

<p>说明：</p>

<ul>
<li>ALIGN   boundary（<font color="red">boundary的值必须是2的幂</font>）。</li>
</ul>



<h3 id="基数控制伪操作">基数控制伪操作</h3>

<p>　　汇编程序默认的数是十进制数，因而除非专门指定，汇编程序把程序中出现的数均看作为十进制数。为此，当使用其他基数的时候，需要专门给以标记：</p>

<table>
<thead>
<tr>
  <th>基数</th>
  <th>标记</th>
</tr>
</thead>
<tbody><tr>
  <td>二进制</td>
  <td>B</td>
</tr>
<tr>
  <td>十进制</td>
  <td>D</td>
</tr>
<tr>
  <td>十六进制</td>
  <td>H</td>
</tr>
<tr>
  <td>八进制</td>
  <td>O 或者 Q</td>
</tr>
</tbody></table>




<pre class="prettyprint"><code class="language-asm hljs asciidoc"><span class="hljs-bullet">. </span>RADIX  表达式        ; 规定无标记数的基数</code></pre>

<pre class="prettyprint"><code class="language-asm hljs avrasm"><span class="hljs-keyword">MOV</span>  BX, <span class="hljs-number">0</span>FFH
<span class="hljs-keyword">MOV</span>  BX, <span class="hljs-number">178</span>

<span class="hljs-preprocessor">.RADIX</span>  <span class="hljs-number">16</span>
<span class="hljs-keyword">MOV</span>  BX, <span class="hljs-number">0</span>FF <span class="hljs-comment">;这里没有标记（不是0FFH），但是因为前面定义了`.RADIX 16`，所以这里仍然表示16进制的数。</span>
<span class="hljs-keyword">MOV</span>  BX, <span class="hljs-number">178</span>D</code></pre>

<h2 id="汇编语言程序格式">汇编语言程序格式</h2>

<p>　　汇编语言源程序中每个语句可以由四项组成，格式如下： <br>
　　</p>



<pre class="prettyprint"><code class=" hljs css"><span class="hljs-attr_selector">[name]</span> <span class="hljs-tag">operation</span> <span class="hljs-tag">operand</span> <span class="hljs-attr_selector">[; comment]</span></code></pre>

<p>　　其中</p>

<ul>
<li>名字（name）项是一个符号。</li>
<li>操作（operation）项是一个操作码的助记符，它可以是指令、伪操作或者宏指令名。</li>
<li>操作数（operand）项是一个或多个表达式组成，它提供为执行所要求的操作而需要的信息。</li>
<li>注释（comment）项是用来说明程序或者语句的功能。;为识别注释项的开始。;也可以从一行的第一个字符开始，此时整行都是注释，常用来说明下面一段程序的功能。</li>
</ul>



<h3 id="名字项">名字项</h3>



<h3 id="操作项">操作项</h3>

<p>　　操作数项由一个或者多个表达式组成，多个操作数项之间一般用逗号分开。 <br>
　　操作数项可以是常数，寄存器，标号，变量或者由表达式组成。表达式是常数，寄存器，标号，变量与一些操作符相结合的序列，可以有数字表达式和地址表达式两种。</p>



<h4 id="算术操作符">算术操作符</h4>

<p>　　 <br>
　　算术操作符有<code>+，-，*，/、MOD</code>。其中MOD是指除法运算后得到的余数。<font color="blue">算术操作符可以用于数字或者地址表达式中，但当它用于地址表达式的时候，只有其结果有明确的物理意义的时候才是有效的结果。</font>例如：两个地址相乘和相除是没有意义的。在地址表达式中，可以使用+或者-，但也必须注意其物理意义，<font color="red">例如把两个不同段的地址相加也是没有意义的。</font>经常使用的是<font color="blue">地址±数字量</font>，它是有意义的，例如，SUM+1是指SUM字节单元的下一个字节单元的地址（<font color="red">注意：不是指SUM单元的内容加1</font>），而SUM-1则是指SUM字节单元的前一个字节单元的地址。</p>



<h4 id="逻辑与移位操作符">逻辑与移位操作符</h4>

<p>　　逻辑操作符有AND,OR,XOR和NOT；移位操作符有SHL和SHR。他们都是按位操作的，只能用于数字表达式中。</p>



<h4 id="关系操作符">关系操作符</h4>

<table>
<thead>
<tr>
  <th>名称</th>
  <th>全称</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>EQ</td>
  <td>Equal</td>
  <td>相等</td>
</tr>
<tr>
  <td>NE</td>
  <td>Not equal</td>
  <td>不想等</td>
</tr>
<tr>
  <td>LT</td>
  <td>Less than</td>
  <td>小于</td>
</tr>
<tr>
  <td>GT</td>
  <td>Great than</td>
  <td>大于</td>
</tr>
<tr>
  <td>LE</td>
  <td>Less and equal</td>
  <td>小于或等于</td>
</tr>
<tr>
  <td>GE</td>
  <td>Great and equal</td>
  <td>大于或等于</td>
</tr>
</tbody></table>


<p>说明：</p>

<ul>
<li><font color="blue">关系操作符的两个操作数必须都是数字，或者同一段内的两个存储器地址。</font></li>
<li>计算结果应为逻辑值，结果为真，表示为0FFFFH；结果为假的时候，则表示为0。</li>
</ul>



<h4 id="数值回送操作符">数值回送操作符</h4>

<p>　　它主要有的TYPE，LENGTH，SIZE，OFFEST，SEG等等。这些操作符把一些特征或者存储器地址的一部分作为数值回送。</p>



<h5 id="type">TYPE</h5>

<p>　　格式为：<code>TYPE expression</code></p>

<p>　　如果该表达式是变量，则汇编程序将回送变量的以字节数表示的类型：<font color="blue">DB=1，DW=2，DD=4，DF=6，DQ=8，DT=10。</font>如果表达式是标号，则汇编程序将回送代表该标号类型的数值：<font color="blue">NEAR=-1，FAR=-2。</font>如果表达式是常数，则应回送<font color="blue">0</font>。</p>



<h2 id="操作数项表达式">操作数项（表达式）</h2>

<ul>
<li>(1)  算术操作符：  +、- 、*、 /、Mod</li>
<li>(2) 逻辑操作符： AND、OR、XOR、NOT，移位操作符:    SHL、SHR</li>
<li>(3) 关系操作符： EQ、NE、LT、LE、GT、GE</li>
<li>(4) 数值回送操作符： TYPE、 LENGTH、 SIZE 、OFFSET、SEG、 <br>
<ul><li>TYPE      变量 / 标号 / 常数</li>
<li>DB、DW、DD、DF、DQ、DT、NEAR、FAR、常数</li>
<li>1、2、4、6、8、10、-1、-2、0(与上面的变量对应)</li></ul></li>
<li>(5)  属性操作符： PTR、段操作符、SHORT、THIS、HIGH、LOW、HIGHWORD、LOWWORD</li>
</ul>



<h3 id="length">LENGTH</h3>

<ul>
<li>LENGTH   变量 <br>
<ul><li>功能：回送由DUP定义的变量的<font color="blue">单元数</font>，其它情况回送1</li>
<li><code>DR2  DW  10H  DUP（0，2  DUP（2））</code>，<code>MOV  CL，LENGTH  DR2</code>CL的值为<font color="blue">10H</font></li>
<li><code>DR1  DB  10H，30H</code>,<code>MOV  BL，LENGTH  DR1</code>BL的值为1。</li></ul></li>
</ul>



<h3 id="size">SIZE</h3>

<ul>
<li>SIZE <br>
<ul><li>变量功能：LENGTH * TYPE</li></ul></li>
</ul>



<h3 id="offset和seg">OFFSET和SEG</h3>

<ul>
<li>OFFSET /  SEG  变量 / 标号 <br>
<ul><li>功能：回送变量或标号的偏址 / 段址</li></ul></li>
</ul>



<h2 id="debug">Debug</h2>

<ul>
<li><p><a href="http://blog.csdn.net/notzuonotdied/article/details/70888205">汇编调试程序Debug使用 </a></p></li>
<li><p>使用DEBUG调试和运行可执行文件 </p>

<ul><li>在初次使用DEBUG时，可参照下列步骤进行: </li>
<li>1、调用DEBUG，装入用户程序</li>
<li>2、U命令反汇编程序，记录代码段与数据段首地址</li>
<li>3、R命令观察寄存器初始状态 </li>
<li>4、以单步工作方式T开始运行程序 ，设置段寄存器的值。</li>
<li>5、D观察用户程序数据段初始内容</li>
<li>6、继续以单步工作方式运行程序 </li>
<li>7．G连续工作方式运行程序</li>
<li>8．E或A修改程序和数据</li>
<li>9．运用断点调试程序 G</li></ul></li>
</ul>



<h1 id="80x86指令系统">80x86指令系统</h1>



<h2 id="空操作指令指令格式nop">空操作指令指令格式：NOP</h2>

<p>　　说明：NOP是英语“No Operation”的缩写。NOP无操作数，所以称为“空操作”。</p>

<p>　　执行NOP指令只使程序计数器PC加1，所以占用一个机器周期。 <br>
　　</p>



<h2 id="通用数据传送指令">通用数据传送指令</h2>

<p>　　数据传送指令：MOV、XCHG、LEA、LDS、LES、PUSH、POP、PUSHF、POPF、CBW、CWD、CWDE。</p>



<h3 id="栈的基本操作">栈的基本操作</h3>

<p>　　<font color="9c27b0">8086CPU的入栈和出栈操作都是以<font color="red"><strong>字</strong></font>为单位进行的。</font></p>



<h4 id="push与pop指令的执行过程">push与pop指令的执行过程</h4>

<p>　　PUSH指令每次只能压入一个字（16位）。</p>



<pre class="prettyprint"><code class="language-ASM hljs fix"><span class="hljs-attribute">push ax
（1）SP </span>=<span class="hljs-string"> SP–2；
（2）将AX中的内容送入SS:SP指向的内存单元处。</span></code></pre>

<p><img src="http://img.blog.csdn.net/20170522165714030?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>



<pre class="prettyprint"><code class="language-ASM hljs fix"><span class="hljs-attribute">pop ax
（1）将SS:SP指向的内存单元处的数据送入ax中；
（2）SP </span>=<span class="hljs-string"> SP+2。</span></code></pre>

<p><img src="http://img.blog.csdn.net/20170522165954814?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<p>说明：</p>

<ul>
<li>每执行一次PUSH，SP指针都会减1。</li>
</ul>



<h3 id="mov指令">MOV指令</h3>

<p>　　指令写法：MOV  DST，SRC <br>
　　执行操作：(DST)&lt;-(SRC) <br>
　　其中DST表示目的操作数，SRC表示源操作数。可以在CPU内部或者在存储器之间传送数据。 <br>
　　说明：</p>

<ul>
<li>SRC和DST的操作类型必须明确而且一致。</li>
<li>DST不能是立即数，而且也不能是CS。 <br>
<ul><li>数据传送指令是不能把数据传送给CS的，因为CS是代码段寄存器，CS如果被修改程序就无法执行。</li></ul></li>
<li>DST、SRC也不能同时是存储器寻址。</li>
<li>DST、SRC也不能同时是段寄存器。</li>
<li><font color="blue">立即数不能直接送段寄存器</font>，必须通过寄存器（比如AX）送达段寄存器。</li>
<li>指令的执行不影响标志位。</li>
<li><font color="blue">立即数可以直接送到存储器</font>，但应指定存储器的类型。如： <br>
<ul><li>mov byte ptr[di], 3</li>
<li>mov word ptr[si], 3000</li>
<li>mov dword ptr[bx], 0FFFFFFh</li></ul></li>
</ul>



<h3 id="xchg指令">XCHG指令</h3>

<p>　　指令格式：   XCHG  OPR1, OPR2 <br>
　　功能：  将操作数地址中的内容互换。 <br>
　　执行操作：   (OPR1)  &lt;-&gt;  (OPR2) <br>
　　注意：</p>

<ul>
<li>指令的执行并不影响标志位。</li>
<li>不允许使用段寄存器，不允许使用立即数，不支持两个存储单元之间的数据交换。</li>
<li>允许字或者字节操作。</li>
</ul>



<h2 id="累加器专用传送指令">累加器专用传送指令</h2>



<h3 id="xlat">XLAT</h3>

<p>　　功能：将表格中的一个字节内容送到AL累加器中。常用于将一种代码转换为另一种代码。 <br>
　　<font color="blue">这条指令根据AL寄存器提供的位移量，将BX指使的字节表格中的代码换存在AL中。</font><code>(AL)&lt;-((DS)*16+(BX)+(AL))</code> <br>
　　说明：本指令并不影响标志位。</p>



<pre class="prettyprint"><code class="language-asm hljs ruleslanguage">格式：
XLAT  <span class="hljs-keyword">TABLE</span>  ;<span class="hljs-keyword">TABLE</span>为表格的起始地址）
XLAT  ;(AL)&lt;-((BX)+(AL))
执行指令前要将<span class="hljs-keyword">TABLE</span>先送入BX，将待查字节与在表格中距离表首地址位移量送AL。</code></pre>

<h2 id="地址传送指令">地址传送指令</h2>

<table>
<thead>
<tr>
  <th>指令</th>
  <th>全称</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>LEA</td>
  <td>load effective address</td>
  <td>有效地址送寄存器</td>
</tr>
<tr>
  <td>LDS</td>
  <td>load DS with pointer</td>
  <td>指针送寄存器和DS</td>
</tr>
<tr>
  <td>LES</td>
  <td>load ES with pointer</td>
  <td>指针送寄存器和ES</td>
</tr>
<tr>
  <td>LFS</td>
  <td>load FS with pointer</td>
  <td>指针送寄存器和FS</td>
</tr>
<tr>
  <td>LGS</td>
  <td>load GS with pointer</td>
  <td>指针送寄存器和GS</td>
</tr>
<tr>
  <td>LSS</td>
  <td>load SS with pointer</td>
  <td>指针送寄存器和SS</td>
</tr>
</tbody></table>




<h3 id="lea">LEA</h3>

<p>　　功能：有效地址送寄存器。 <br>
　　全称：load effective address</p>



<pre class="prettyprint"><code class="language-asm hljs brainfuck"><span class="hljs-comment">LEA</span> <span class="hljs-comment">BX</span><span class="hljs-string">,</span><span class="hljs-comment">LIST</span> <span class="hljs-comment">;</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">取LIST的偏移地址送BX</span>     
<span class="hljs-comment">MOV</span> <span class="hljs-comment">BX</span><span class="hljs-string">,</span> <span class="hljs-comment">OFFSET</span> <span class="hljs-comment">LIST</span> <span class="hljs-comment">;</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">功能与LEA相同</span>       
<span class="hljs-comment">LEA</span> <span class="hljs-comment">BX</span><span class="hljs-string">,</span> <span class="hljs-title">[</span><span class="hljs-comment">BX</span><span class="hljs-literal">+</span><span class="hljs-comment">SI</span><span class="hljs-title">]</span> <span class="hljs-comment">;</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">取基址变址寻址的有效地址给BX</span>  </code></pre>

<p>　　<code>MOV BX, OFFSET [BX+SI] ;</code>——× <font color="red">注意：OFFSET只能与简单的符号地址相连。</font></p>



<h2 id="算术指令">算术指令</h2>

<p>　　算术运算指令会根据运算结果影响状态标志，主要影响6个标志位：ZF、CF、AF、SF、OF和PF。</p>



<h3 id="加法指令">加法指令</h3>

<table>
<thead>
<tr>
  <th>指令</th>
  <th>使用</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>ADD</td>
  <td>ADD DST,SRC</td>
  <td>功能：加法，将SRC和DST的值相加之后存放在DST中。<br>执行操作： (DST)  &lt;-  (SRC) + (DST)</td>
</tr>
<tr>
  <td>ADC</td>
  <td>ADC DST, SRC</td>
  <td>功能：带进位的加法指令，将SRC和DST的值和进位标志位（CF）相加之后存放在DST中。<br>执行操作：(DST)  &lt;-  (SRC) + (DST) + CF</td>
</tr>
<tr>
  <td>INC</td>
  <td>INC OPR</td>
  <td>功能：加一指令。<br>执行操作：(OPR)  &lt;-  (OPR) + 1</td>
</tr>
</tbody></table>


<p>　　<font color="blue">说明：加法指令都会影响条件标志位，但INC指令不影响CF标志。</font> <br>
　　INC影响的条件标志位包括：<font color="blue">SF,ZF,OF,AF,PF。</font></p>



<h4 id="adc指令的作用">adc指令的作用</h4>

<p>　　在执行 adc 指令的时候加上的 CF 的值是由 adc指令前面的指令决定的，也就是说，关键在于所加上的CF值是被什么指令设置的。 <br>
　　下面的指令和add ax , bx具有相同的结果：  <br>
　　</p>



<pre class="prettyprint"><code class="language-asm hljs avrasm"> <span class="hljs-keyword">add</span> al,bl   
 <span class="hljs-keyword">adc</span> ah,bh</code></pre>

<p>　　<font color="blue">看来CPU提供 ADC指令的目的，就是来进行加法的第二步运算的。</font>ADC指令和ADD指令相配合就可以对更大的数据进行加法运算。 <br>
　　注意：有符号的双精度数的溢出，应根据ADC指令的OF位判断，而作<font color="blue">低位加法</font>用的ADD指令的溢出是无意义的。 <br>
　　<strong>用16位寄存器编写程序：</strong></p>

<pre class="prettyprint"><code class="language-asm hljs livecodeserver">
MOV  AX, <span class="hljs-built_in">word</span> ptr d1    ;由于d1是双字类型，必须使用强制类型说明符。
MOV  DX, <span class="hljs-built_in">word</span> ptr d1+<span class="hljs-number">2</span>  ;(DX,AX)构成一个<span class="hljs-number">32</span>位数据
ADD  AX, <span class="hljs-built_in">word</span> ptr d2    ;低字相加，有可能会产生“进位”
ADC  DX, <span class="hljs-built_in">word</span> ptr d2+<span class="hljs-number">2</span>  ;高字相加。
MOV  <span class="hljs-built_in">word</span> ptr d1, AX    ;低字送给d1的低字
MOV  <span class="hljs-built_in">word</span> ptr d1+<span class="hljs-number">2</span>, DX  ;高字送给d1的高字
</code></pre>

<p><strong>说明：</strong> <br>
　　<font color="blue">OF位可以用来表示带符号数的溢出，CF位可以用来表示无符号数的溢出。</font> <br>
　　条件标志（或者称呼为）位中最主要的是CF,ZF,SF,OF四位，分别表示了进位、结果为零，符号和溢出的情况。 <br>
　　执行加法指令的时候，CF位是根据最高有效位是否向最高位的进位来设置的。有进位的时候CF=1，无进位的时候CF=0。 <br>
　　OF位则根据操作数的符号及其变化情况来设置的：<font color="blue">若两个操作数的符号相同，而结果的符号与之相反则OF=1，否则OF=0。</font></p>

<ul>
<li>注意区分OF是根据原先的符号位来判断的。</li>
</ul>

<hr>

<p>　　溢出位OF既然试试根据数的符号及其变化来设置的，当然它是用来表示带符号数的溢出的，从其设置条件来看结论也是明显的。 <br>
　　CF位可以用来表示无符号数的溢出。一方面，由于无符号数的最高有效位只有数值意义而无符号意义，所以该位产生的进位应该是结果的实际的进位值，但是在有限数位的范围内就说明了结果的溢出情况；另一方面，它所保存的进位值有时候还是有用的。例如。双字长数运算的时候，可以利用进位值把低位字的进位计入高位字中。    </p>

<h3 id="减法指令">减法指令</h3>

<table>
<thead>
<tr>
  <th>指令</th>
  <th>使用</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>SUB</td>
  <td>SUB DST,SRC</td>
  <td>功能：减法，将SRC和DST的值相减之后存放在DST中。<br>执行操作： (DST)  &lt;-  (SRC) + (DST)</td>
</tr>
<tr>
  <td>SBB</td>
  <td>SUB DST, SRC</td>
  <td>功能：带借位减法指令，将SRC和DST的值和进位标志位（CF）相加之后存放在DST中。<br>执行操作：(DST)  &lt;-  (SRC) + (DST) - CF<br>CF为进位位的值。</td>
</tr>
<tr>
  <td>DEC</td>
  <td>DEC OPR</td>
  <td>功能：加一指令。<br>执行操作：(OPR)  &lt;-  (OPR) + 1</td>
</tr>
<tr>
  <td>NEG</td>
  <td>NEG OPR</td>
  <td>功能：加一指令。<br>执行操作：(OPR)  &lt;-  (OPR) + 1<br>把操作数按位求反后末尾加1。</td>
</tr>
<tr>
  <td>CMP</td>
  <td>CMP  OPR1, OPR2</td>
  <td>功能：加一指令。<br>执行操作： (OPR1) - (OPR2)<br>执行减法操作，不保存结果。往往根据比较发生转移。</td>
</tr>
</tbody></table>


<p><font color="red">说明：</font> <br>
　　减法运算的条件码情况和加法类似。CF位说明无符号数相减的溢出，同时它又确实是被减数的最高有效位向高位的<font color="blue">借位值</font>。OF位则说明带符号数的溢出。 <br>
　　<font color="blue">减法的CF值</font>反映了无符号数运算中的借位情况，因此当作为无符号运算时，若减数&gt;被减数，此时有借位，则CF=1；否则CF=0。或者，也可以简单地用二进制减法的运算中的最高有效位向高位的进位的情况来判别：<font color="blue">有进位的时候CF=0，没有进位的时候CF=1。</font> <br>
　　减法的OF位的设置方法为：<font color="blue">若两个数的符号相反，而结果的符号与减数相同则相同，则OF=1；除了上述情况外OF=0</font>。<font color="red">OF=1说明带符号数的减法溢出，结果是错误的。</font> <br>
　　<font color="blue">NEG</font>指令的条件码按照求补后的结果设置，<font color="blue">只有当操作数为0的时候，求补运算的结果使得<strong>CF=0</strong>，其他情况都为<strong>CF=1</strong></font>。所以，只有当字运算时对-128求补的时候，以及字运算的时候对-32768求补以及双字运算的时候对-2^31求补的情况下<strong>OF=1</strong>，其他则均为<strong>OF=0</strong>。</p>



<h3 id="乘法指令">乘法指令</h3>

<table>
<thead>
<tr>
  <th>指令</th>
  <th>使用</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>MUL</td>
  <td><font color="red">无符号数</font>乘法指令</td>
  <td>MUL SRC</td>
</tr>
<tr>
  <td>IMUL</td>
  <td><font color="red">带符号数</font>乘法指令</td>
  <td>IMUL SRC</td>
</tr>
</tbody></table>


<table>
<thead>
<tr>
  <th>类型</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>字节操作数</td>
  <td>(AX) &lt;-  (AL) * (SRC)</td>
</tr>
<tr>
  <td>字操作数</td>
  <td>(DX, AX) &lt;-  (AX) * (SRC)</td>
</tr>
</tbody></table>


<p><font color="red"><strong>注意:</strong></font>   </p>

<ul>
<li>AL (AX) 为<font color="red">隐含</font>的乘数寄存器。</li>
<li>AX (DX,AX) 为<font color="red">隐含</font>的乘积寄存器。 CPU会根据乘数是8位、16位，还是32位操作数，来<font color="blue">自动</font>选用被乘数：AL、AX或EAX。</li>
<li>SRC不能为立即数。</li>
<li>除CF和OF外，对条件标志位无定义。</li>
<li>当乘积的高半部分不为0时，CF=1，OF=1。</li>
</ul>



<h3 id="除法指令">除法指令</h3>

<table>
<thead>
<tr>
  <th>指令</th>
  <th>使用</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>DIV</td>
  <td>无符号数除法指令</td>
  <td>DIV SRC</td>
</tr>
<tr>
  <td>IDIV</td>
  <td>带符号数除法指令</td>
  <td>IDIV SRC</td>
</tr>
</tbody></table>


<table>
<thead>
<tr>
  <th>类型</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>字节操作数</td>
  <td>(AL) &lt;- (AX) / (SRC) 的商<br>(AH) &lt;- (AX) / (SRC) 的余数</td>
</tr>
<tr>
  <td>字操作数</td>
  <td>(AX) &lt;- (DX, AX) / (SRC) 的商<br>(DX) &lt;- (DX, AX) / (SRC) 的余数</td>
</tr>
</tbody></table>


<p><font color="red"><strong>注意:</strong></font>   </p>

<ul>
<li>AX (DX,AX) 为隐含的被除数寄存器。</li>
<li>AL (AX) 为隐含的商寄存器。</li>
<li>AH (DX) 为隐含的余数寄存器。</li>
<li>SRC不能为立即数。</li>
<li>对所有条件标志位<font color="red"><strong>均无定义</strong></font>。但是可能产生<font color="red">溢出</font>。 <br>
<ul><li>执行除法指令后，对AF，CF，OF，PF，SF，ZF标志位的影响都不确定。</li></ul></li>
</ul>



<h3 id="标志寄存器传送指令">标志寄存器传送指令</h3>

<table>
<thead>
<tr>
  <th>指令</th>
  <th align="center">全称</th>
  <th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
  <td>LAHF</td>
  <td align="center">load AH with flags</td>
  <td align="right">标志送AH</td>
</tr>
<tr>
  <td>SAHF</td>
  <td align="center">store AH into flags</td>
  <td align="right">AH送标志寄存器</td>
</tr>
<tr>
  <td>PUSHF/PUSHFD</td>
  <td align="center">push the flags or eflags</td>
  <td align="right">标志进栈</td>
</tr>
<tr>
  <td>PUPF/POPFD</td>
  <td align="center">pop the flags or eflags</td>
  <td align="right">标志出栈</td>
</tr>
</tbody></table>


<p><font color="red"><strong>注意:</strong></font>   </p>

<ul>
<li><p>这组指令中的LAHF和PUSHF/PUSHFD都不影响标志位。SAHF和POPF/POPFD则由装入的值来确定标志位的值，但是POPFD指令不影响VM,RF,IOPF,VIF和VIP的值。</p></li>
<li><p>STC－－－－是置进位标志指令，执行的结果是将进位标志CF置1</p></li>
<li>CLC－－－－是清进位标志指令，其执行结果是置CF标志为0</li>
</ul>



<h3 id="类型转换指令">类型转换指令</h3>

<table>
<thead>
<tr>
  <th>指令</th>
  <th>使用</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>CBW</td>
  <td>字节转换为字</td>
  <td>AL符号扩展到AH中，形成AX中的字。即如果(AL)中的最高有效位是0，则(AH)=0；如(AL)的最高有效位为1，则(AH)=0FFH。<br><font color="blue">执行操作：</font> <br>若(AL)的最高有效位为0，则(AH)= 00H<br>若(AL)的最高有效位为1，则(AH)= FFH</td>
</tr>
<tr>
  <td>CWD/CWDE</td>
  <td>字转换为双字</td>
  <td>AX符号扩展 -&gt; (DX,AX)双字<br>执行操作：<br>若(AX)的最高有效位为0，则(DX)= 0000H<br>若(AX)的最高有效位为1，则(DX)= FFFFH</td>
</tr>
<tr>
  <td>CWQ</td>
  <td>双字转换为4字</td>
  <td>EAX的内容符号扩展到EDX，形成EDX:EAX中的4字。</td>
</tr>
<tr>
  <td>BSWAP</td>
  <td>字节交换指令</td>
  <td>格式：BASWAP r32。<br>该指令只能用于486及其后继机型。r32指32位寄存器。<br>执行的操作：使指令指定的32位寄存器的字节次序变反。具体的操作为：1、4字节互换，2</td>
</tr>
</tbody></table>


<p><font color="red"><strong>注意:</strong></font>   </p>

<ul>
<li>隐含对AL 或AX 进行符号扩展</li>
<li>本组指令都不影响条件标志位</li>
</ul>



<h2 id="逻辑指令">逻辑指令</h2>



<h3 id="逻辑运算指令">逻辑运算指令</h3>

<table>
<thead>
<tr>
  <th>指令</th>
  <th>全称</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>AND</td>
  <td>and</td>
  <td>逻辑与<br>格式：AND DST,SRC</td>
</tr>
<tr>
  <td>OR</td>
  <td>or</td>
  <td>逻辑或<br>格式：OR DST,SRC</td>
</tr>
<tr>
  <td>NOT</td>
  <td>not</td>
  <td>逻辑非<br>格式：NOT DST,SRC</td>
</tr>
<tr>
  <td>XOR</td>
  <td>exclusive or</td>
  <td>异或<br>格式：XOR DST,SRC</td>
</tr>
<tr>
  <td>TEST</td>
  <td>test</td>
  <td>作用：测试<br>格式：TEST OPR1,OPR2<br>执行的操作：(OPR1)∧(OPR2)<br>说明：两个操作数相与的结果<font color="red">不保存</font>，只是根据其特征置条件码。</td>
</tr>
</tbody></table>


<p><font color="red"><strong>注意:</strong></font>   </p>

<ul>
<li>在以上的五种指令中，NOT不允许存放立即数。</li>
<li>其他4条指令除非源操作数是立即数，至少有一个操作数必须存放在寄存器中，另一个操作数则可以使用任意寻址方式。</li>
<li>NOT不影响标志为。</li>
<li>其他4种指令将使CF位和OF位为0，AF位无定义，而SF位、ZF位和PF位则根据运算结果设置。</li>
<li><font color="blue">这些指令对处理操作数的某些位很有用，例如可以屏蔽某些位（将这些位置0），或者使某些位置1或者测试某些位等等。</font></li>
</ul>



<h4 id="and">AND</h4>

<p>　　要求屏蔽0、1两位，可以用AND指令并设置常数0FCH。 <br>
　　</p>



<pre class="prettyprint"><code class="language-asm hljs avrasm"><span class="hljs-keyword">MOV</span> AL,<span class="hljs-number">0</span>BFH
<span class="hljs-keyword">AND</span> AL,<span class="hljs-number">0</span>FCH</code></pre>

<p>　　这两条指令的运行结果使得(AL)=0BCH。因此，<font color="blue">使用AND指令可以使得操作数的某些位被屏蔽</font>。只需要把AND指令的源操作数设置成一个立即数，并把需要屏蔽的位设置为0，这样指令执行的结果就可以把操作数的相应位置0，其他位保持不变。</p>

<h4 id="or">OR</h4>

<p>　　要求第5位置1，可以使用OR指令。</p>



<pre class="prettyprint"><code class="language-asm hljs avrasm"><span class="hljs-keyword">MOV</span> AL,<span class="hljs-number">43</span>H
<span class="hljs-keyword">MOV</span> AL,<span class="hljs-number">20</span>H</code></pre>

<p>　　这两条指令执行了之后，(AL)=63 H。因此，<font color="blue">用OR指令可以使得操作数的某些位置1，其他位保持不变。</font>只需要把OR指令的源操作数设置为一个立即数，并把需要置1的位设置为1，就可以达到目的了。</p>

<h4 id="test">TEST</h4>

<p>　　要测试操作数的某些位是否为0，可以使用TEST指令，同样把TEST指令的源操作数设置成一个立即数，其中需要测试的位应该设置为1。 <br>
　　</p>



<pre class="prettyprint"><code class="language-asm hljs avrasm"><span class="hljs-keyword">MOV</span> AL,<span class="hljs-number">40</span>H
TEST AL,<span class="hljs-number">0</span>AFH</code></pre>

<p>　　这里要求测试第0，1，2，3，5，7位是否为0，根据测试的结果设置条件码为CF=OF=0，SF=0，ZF=1，说明了所需要测试的位均为0。如果在这两条指令之后跟一条件转移指JNZ，结果如果不是0就转移，结果如果是0就顺序往下执行，这样就可以根据测试的情况产生不同的程序分支，转向不同的处理方案了。</p>

<h4 id="not">NOT</h4>

<p>　　要测试操作数的某位是否为1，可以先把该操作数求反，然后使用TEST指令测试。如要测试AL寄存器中第2位是否为1，若为1则转移到EXIT中去执行，可以用下列指令序列： <br>
　　</p>



<pre class="prettyprint"><code class="language-asm hljs vbnet">MOV DL,AL
<span class="hljs-keyword">NOT</span> DL
TEST DL,<span class="hljs-number">0000</span> <span class="hljs-number">0100</span>B
JE <span class="hljs-keyword">EXIT</span></code></pre>

<p>　　如AL寄存器的内容为0FH，为了避免破坏操作数的原始内容，把它复制到了DL中去测试，执行完TEST指令之后，结果为全0而有ZF=1，说明操作数的第2位为1引起的转移到EXIT去执行。</p>

<h4 id="xor">XOR</h4>

<p>　　<font color="blue">要是操作数的某些位变反，可以使用XOR指令，只要把源操作数的立即数字段的相应位置设置为1就可以达到目的。</font>如果求第0，1位变反，可以使用下面的指令： <br>
　　</p>



<pre class="prettyprint"><code class="language-asm hljs php">MOV AL,<span class="hljs-number">11</span>H
<span class="hljs-keyword">XOR</span> AL,<span class="hljs-number">3</span></code></pre>

<p>　　则指令执行后，(AL)=12H，达到了第0，1位变反而其他位不变的目的。 <br>
　　<font color="blue">XOR指令还可以用来测试某一个操作数是否与另外一个确定的操作数相等。</font>这种操作在检查地址是否匹配的时候是经常使用的。 <br>
　　</p>

<pre class="prettyprint"><code class="language-asm hljs php"><span class="hljs-keyword">XOR</span> AX,<span class="hljs-number">042</span>EH
JZ MATCH</code></pre>

<p>　　这两条指令是用来检查AX的内容是否等于042EH，若相等则转移到MATCH去执行匹配的情况需要做的工作，否则执行JZ下面的程序。</p>

<h3 id="位测试并修改指令">位测试并修改指令</h3>

<p>　　386及其后继机型增加了本组指令。</p>



<h3 id="位扫描指令">位扫描指令</h3>

<p>　　386及其后继机型增加了本组指令。</p>



<h3 id="移位指令-这里编辑未完成">移位指令-这里编辑未完成</h3>

<table>
<thead>
<tr>
  <th>指令</th>
  <th>全称</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>SHL</td>
  <td>shift logical left</td>
  <td>逻辑左移</td>
</tr>
<tr>
  <td>SAL</td>
  <td>shift arithmetic left</td>
  <td>算术左移</td>
</tr>
<tr>
  <td>SHR</td>
  <td>shift logical right</td>
  <td>逻辑右移</td>
</tr>
<tr>
  <td>SAR</td>
  <td>shift arithmetic right</td>
  <td>算术右移</td>
</tr>
<tr>
  <td>ROL</td>
  <td>rotat left</td>
  <td>循环左移</td>
</tr>
<tr>
  <td>ROR</td>
  <td>rotat right</td>
  <td>循环右移</td>
</tr>
<tr>
  <td>RCL</td>
  <td>rotate left through carry</td>
  <td>带进位循环左移</td>
</tr>
<tr>
  <td>RCR</td>
  <td>rotate right through carry</td>
  <td>带进位循环右移</td>
</tr>
<tr>
  <td>SHLD</td>
  <td>shift left double</td>
  <td>双精度左移</td>
</tr>
<tr>
  <td>SHRD</td>
  <td>shift right double</td>
  <td>双精度右移</td>
</tr>
</tbody></table>


<p><font color="red">注意:</font>   </p>

<ul>
<li>OPR可用除立即数以外的任何寻址方式 </li>
<li>移位次数CNT=1，<code>SHL OPR, 1</code></li>
<li>CNT&gt;1，<code>MOV  CL, CNT</code>,<code>SHL OPR, CL</code></li>
<li>条件标志位： <br>
<ul><li>CF = 移入的数值</li>
<li>OF = 1    CNT=1时，最高有效位的值发生变化</li>
<li>OF = 0    CNT=1时，最高有效位的值不变</li></ul></li>
<li>循环移位指令： <br>
<ul><li>不影响 SF、ZF、PF、AF</li></ul></li>
<li>移位指令： <br>
<ul><li>常用来作乘以2或除以2 的操作。</li>
<li>SAL:有符号数乘以2，SAR有符号数除以2；</li>
<li>SHL:无符号数乘以2，SHR: 无符号数除以2。</li></ul></li>
</ul>

<table>
<thead>
<tr>
  <th>移位指令</th>
  <th>移位填充方式</th>
</tr>
</thead>
<tbody><tr>
  <td>逻辑左移</td>
  <td>右边统一添0，移出来的那一位放进CF</td>
</tr>
<tr>
  <td>算术左移</td>
  <td>右边统一添0，移出来的那一位放进CF</td>
</tr>
<tr>
  <td>逻辑右移</td>
  <td>左边统一添0，移出来的那一位放进CF</td>
</tr>
<tr>
  <td>算术右移</td>
  <td>左边添加<strong>符号位上的数</strong>，移出来的那一位放进CF</td>
</tr>
</tbody></table>


<p>　　示例：<code>1010101010</code>，其中<code>[]</code>是添加的位 <br>
 　　逻辑左移一位：<code>010101010[0]</code> <br>
 　　算术左移一位：<code>010101010[0]</code> <br>
 　　逻辑右移一位：<code>[0]101010101</code> <br>
 　　算术右移一位：<code>[1]101010101</code></p>



<h2 id="控制转移指令">控制转移指令</h2>

<p>　　一般情况下指令都是顺序逐条执行的，但是实际上程序不可能全部顺序执行而经常需要改变程序的执行流程。</p>



<h3 id="无条件转移指令jmp">无条件转移指令JMP</h3>

<ul>
<li>段内直接短转移： <br>
<ul><li>JMP    SHORT  OPR</li>
<li>执行操作：(IP) ← (IP) + 8位位移量</li>
<li><font color="blue">short</font>：表示实现的是段内直接短转移，即位移量为8位数据，它对IP的修改范围为 -128~127，也就是说，它向前转移时可以最多越过128个字节，向后转移可以最多越过127个字节。</li></ul></li>
<li>段内直接近转移：（<font color="blue">转向的符号地址</font>） <br>
<ul><li>JMP    NEAR PTR  OPR</li>
<li>执行操作：(IP) ← (IP) + 16位位移量</li></ul></li>
<li>段内间接转移：（<font color="blue">除立即数以外的寻址方式</font>） <br>
<ul><li>JMP    WORD PTR  OPR</li>
<li>执行操作：    (IP) ← (EA)</li></ul></li>
<li>段间直接远转移：（<font color="blue">转向的符号地址</font>） <br>
<ul><li>JMP    FAR PTR  OPR</li>
<li>执行操作： <br>
<ul><li>(IP) ← OPR 的段内偏移地址 </li>
<li>(CS) ← OPR 所在段的段地址</li></ul></li></ul></li>
<li>段间间接转移：（<font color="blue">存储器寻址方式</font>） <br>
<ul><li>JMP    DWORD PTR  OPR</li>
<li>执行操作： <br>
<ul><li>(IP) ← (EA)</li>
<li>(CS) ← (EA+2)</li></ul></li></ul></li>
</ul>

<p><font color="red">注意：</font></p>

<ul>
<li><font color="red">执行JMP指令的时候，IP改变两次。</font> <br>
<ul><li>第一次是在读取指令的时候，JMP指令被读取放到了指令缓冲期中，这个时候IP改变了一次；之后，JMP指令执行的时候进行了跳转，IP又改变了一次。所以IP总共改变了两次。</li></ul></li>
</ul>



<h3 id="条件转移指令">条件转移指令</h3>

<p>　　<font color="blue">注意：只能使用段内直接寻址的8 位位移量。</font> <br>
　　 <br>
　　 1)根据单个条件标志的设置情况转移：</p>

<table>
<thead>
<tr>
  <th>格式</th>
  <th>全称</th>
  <th>转移条件</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>JZ(JE) OPR</td>
  <td>jump if zero,or equal</td>
  <td>ZF = 1</td>
  <td>结果为0（相等）则转移</td>
</tr>
<tr>
  <td>JNZ(JNE)  OPR</td>
  <td>jump if not zero, or not equal</td>
  <td>ZF = 0</td>
  <td>不为0（不相等）转移</td>
</tr>
<tr>
  <td>JS OPR</td>
  <td>jump if sign</td>
  <td>SF = 1</td>
  <td>为负转移</td>
</tr>
<tr>
  <td>JNS OPR</td>
  <td>jump if not sign</td>
  <td>SF = 0</td>
  <td>为正转移</td>
</tr>
<tr>
  <td>JO OPR</td>
  <td>jump if overflow</td>
  <td>OF = 1</td>
  <td>溢出转移</td>
</tr>
<tr>
  <td>JNO OPR</td>
  <td>jump if not overflow</td>
  <td>OF = 0</td>
  <td>不溢出转移</td>
</tr>
<tr>
  <td>JP OPR</td>
  <td>jump if parity, or parity even</td>
  <td>PF = 1</td>
  <td>有偶数个1则转移</td>
</tr>
<tr>
  <td>JNP OPR</td>
  <td>jump if not parity, or parity odd</td>
  <td>PF = 0</td>
  <td>有奇数个1 则转移</td>
</tr>
<tr>
  <td>JC OPR</td>
  <td>jump if carry</td>
  <td>CF = 1</td>
  <td>有进位转移</td>
</tr>
<tr>
  <td>JNC OPR</td>
  <td>jump if not cary</td>
  <td>CF = 0</td>
  <td>无进位转移</td>
</tr>
</tbody></table>


<p>　　 <br>
　　 2)比较两个无符号数，并根据比较结果转移的指令（与比较指令<strong>CMP</strong> 联用）</p>

<table>
<thead>
<tr>
  <th>符号表示</th>
  <th>格式</th>
  <th>全称</th>
  <th>转移条件</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>＜</td>
  <td>JB (JNAE,JC) OPR</td>
  <td>jump if below</td>
  <td>CF = 1</td>
  <td>有借位,被减数小于减数则转移</td>
</tr>
<tr>
  <td>≥</td>
  <td>JNB (JAE,JNC)  OPR</td>
  <td>jump if not below</td>
  <td>CF = 0</td>
  <td>没有借位, 被减数大于或等于减数则转移</td>
</tr>
<tr>
  <td>≤</td>
  <td>JNA (JBE) OPR</td>
  <td>jump if not above,<br>jump if below of equal</td>
  <td>CF∨ZF = 1</td>
  <td>被减数小于或等于减数则转移</td>
</tr>
<tr>
  <td>＞</td>
  <td>JA (JNBE) OPR</td>
  <td>jump if above,<br>jump if not below or not equal</td>
  <td>CF ∨ ZF = 0</td>
  <td>被减数大于减数则转移</td>
</tr>
</tbody></table>


<p><strong>说明：</strong> </p>

<ul>
<li>适用于地址或双精度数低位字的比较。</li>
</ul>

<hr>

<p>　　<font color="blue"><strong>无符号数比较示例：</strong></font><code>cmp ax,bx</code> <br>
　　 <br>
<img src="http://img.blog.csdn.net/20170531195646596?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<p>　　<font color="blue"><strong>cmp指令对有符号数的比较：</strong></font><code>cmp   ah, bh</code></p>

<ul>
<li><strong>１、如果SF=1，而OF=0， (ah)&lt;(bh)</strong> <br>
<ul><li>OF=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负；SF=1表示实际结果为负，所以逻辑上真正的结果为负，所以(ah)&lt;(bh)。</li></ul></li>
<li><strong>２、如果SF=0，而OF=1 ，(ah)&lt;(bh)</strong> <br>
<ul><li>OF=1 ，说明有溢出，逻辑上真正结果的正负≠实际结果的正负；SF=0表示由于溢出导致了实际结果非负，那么逻辑上真正的结果必然为负。这样，SF=0，OF = 1 ，说明了(ah)&lt;(bh)。 </li></ul></li>
<li><strong>３、如果SF=0，而OF=0， (ah)≥(bh)</strong> <br>
<ul><li>OF=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负；SF=0表示实际结果非负，所以逻辑上真正的结果必然非负。所以(ah)≥(bh)。 </li></ul></li>
<li><strong>４、如果SF=1，而OF=1， (ah)&gt;(bh)</strong> <br>
<ul><li>OF=1 ，说明有溢出，逻辑上真正结果的正负≠实际结果的正负； SF=1 表示由于溢出导致了实际结果为负，那么逻辑上真正的结果必然为正。这样，SF=1，OF = 1 ，说明了(ah)&gt;(bh)。 </li></ul></li>
</ul>

<hr>

<p>　　3)比较两个带符号数，并根据比较结果转移的指令</p>

<table>
<thead>
<tr>
  <th>符号表示</th>
  <th>格式</th>
  <th>全称</th>
  <th>转移条件</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>＜</td>
  <td>JL (JNGE) OPR</td>
  <td>jump if less</td>
  <td>SF∀OF = 1</td>
  <td>小于，或者不大于或等于则转移。</td>
</tr>
<tr>
  <td>≥</td>
  <td>JNL (JGE) OPR</td>
  <td>jump if not less</td>
  <td>SF∀OF = 0</td>
  <td>不小于，或者大于或等于则转移。</td>
</tr>
<tr>
  <td>≤</td>
  <td>JNG (JLE ) OPR</td>
  <td>jump if not greater</td>
  <td>(SF∀OF)∨ZF = 1</td>
  <td>不大于或者小于或等于则转移。</td>
</tr>
<tr>
  <td>＞</td>
  <td>JG (JNLE) OPR</td>
  <td>jump if greater</td>
  <td>(SF∀OF)∨ZF = 0</td>
  <td>大于或者不小于或等于则转移。</td>
</tr>
</tbody></table>


<p><strong>说明：</strong></p>

<ul>
<li><p>适用于带符号数的比较</p>

<p>　　 4)测试 CX 的值为 0 则转移的指令</p></li>
</ul>

<table>
<thead>
<tr>
  <th>格式</th>
  <th>全称</th>
  <th>测试条件</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>JCXZ OPR</td>
  <td>jump if CX register is zero</td>
  <td>(CX)=0</td>
  <td>CX寄存器的内容为零则转移。</td>
</tr>
</tbody></table>




<h2 id="循环指令">循环指令</h2>



<h3 id="loop">Loop</h3>



<pre class="prettyprint"><code class="language-C hljs axapta"><span class="hljs-comment">// 计算0+1+2+3+4+5+6+7+8+9的值</span>
<span class="hljs-keyword">int</span> <span class="hljs-keyword">sum</span>=<span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)
    <span class="hljs-keyword">sum</span>=<span class="hljs-keyword">sum</span>+i;</code></pre>

<p>　　相当于：</p>



<pre class="prettyprint"><code class="language-asm hljs avrasm">// 计算<span class="hljs-number">0</span>+<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">3</span>+<span class="hljs-number">4</span>+<span class="hljs-number">5</span>+<span class="hljs-number">6</span>+<span class="hljs-number">7</span>+<span class="hljs-number">8</span>+<span class="hljs-number">9</span>的值
     <span class="hljs-keyword">mov</span> ax,<span class="hljs-number">0</span><span class="hljs-comment">; ax相当于sum</span>
     <span class="hljs-keyword">mov</span> bx,<span class="hljs-number">0</span><span class="hljs-comment">; bx相当于i</span>
     <span class="hljs-keyword">mov</span> cx,<span class="hljs-number">10</span>
     <span class="hljs-comment">;标号s代表一个地址</span>
<span class="hljs-label">s:</span>   <span class="hljs-keyword">add</span> ax,bx
     <span class="hljs-keyword">inc</span> bx
     loop s<span class="hljs-comment">; 判断</span></code></pre>

<p>　　指令的格式是：<code>loop　标号</code> <br>
　　CPU 执行loop指令的时候，要进行两步操作： <br>
　　① (cx)=(cx)-1； <br>
　　② 判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行，退出循环。 <br>
　　可见，cx中的值影响着loop指令的执行结果。<font color="blue">用loop指令来实现循环功能时，cx 中要存放循环次数。</font> <br>
　　一条循环指令<code>LOOP AGAIN</code>可以用<font color="blue">修改循环计数和判断转移条件的两条指令</font>替代<code>DEC CX</code>,<code>JNZ AGAIN</code>。JNZ(或JNE)结果不为零（或不相等）则转移，测试条件为ZF=0。 <br>
　　我们可以总结出用cx和loop 指令相配合实现循环功能的三个要点：</p>

<ul>
<li>1）在cx中要存放循环次数；</li>
<li>2）loop 指令中的标号所标识地址要在前面；</li>
<li>3）要循环执行的程序段，要写在标号和 loop 指令的中间。</li>
<li>4）loop指令的执行<font color="blue">不影响条件码标志位。</font></li>
</ul>

<h3 id="loop示例">LOOP示例</h3>



<pre class="prettyprint"><code class="language-asm hljs avrasm"><span class="hljs-keyword">MOV</span> CX,<span class="hljs-number">0</span>
<span class="hljs-label">S:</span>
<span class="hljs-keyword">ADD</span> AX,BX
LOOP S</code></pre>

<p>　　以上指令序列执行后ADD AX,BX指令被执行了多少次？ <br>
 　　答案是：65536次。</p>

<p>　　循环 LOOP (loop) <br>
　　指令的汇编格式：LOOP label <br>
　　指令的基本功能： <br>
　　①<code>(CX)←(CX)－1</code> <br>
　　② 若<code>(CX)≠0</code>，则<code>(IP)←(IP)当前＋位移量</code>，否则循环结束。 <br>
　　指令的特殊要求：循环指令都是短转移格式的指令，也就是说，位移量是用8位带符号数来表示的，转向地址在相对于当前IP值的－128 ~ ＋127字节范围之内。 <br>
　 <br>
　　解析：<font color="blue">LOOP指令是先执行CX自减的功能，之后才进行循环的</font>。只要CX不为0，循环就不会终止。因此在上面中，第一次执行的时候，CX自减为0FFFFH，这时CX就不为0的，循环不会被终止。由此，我们可以算出总共运行了65536次。</p>

<h3 id="可提前结束的循环指令">可提前结束的循环指令</h3>

<table>
<thead>
<tr>
  <th>功能</th>
  <th>格式</th>
  <th>测试条件</th>
</tr>
</thead>
<tbody><tr>
  <td>当为0或相等时循环</td>
  <td><code>LOOPZ / LOOPE 标号</code></td>
  <td>ZF=1且（CX）≠0</td>
</tr>
<tr>
  <td>不为0或不相等循环</td>
  <td><code>LOOPNZ / LOOPNE 标号</code></td>
  <td>ZF=0且（CX）≠ 0</td>
</tr>
</tbody></table>


<p><strong>执行步骤：</strong> </p>

<ul>
<li>1)   <code>(CX) ← (CX) - 1</code>；</li>
<li>2)   检查是否满足测试条件，如满足则实现循环；不满足则退出循环。</li>
</ul>

<hr>

<p><strong>注意：</strong></p>

<ul>
<li>CX 中存放循环次数；</li>
<li>与比较指令<code>CMP</code>联合使用可提前退出循环。</li>
</ul>



<h2 id="串处理指令">串处理指令</h2>

<table>
<thead>
<tr>
  <th>串处理指令</th>
  <th>指令</th>
  <th>串重复前缀</th>
  <th>设置方向标志指令</th>
</tr>
</thead>
<tbody><tr>
  <td>串传送</td>
  <td>MOVSB  /  MOVSW</td>
  <td>REP</td>
  <td>CLD</td>
</tr>
<tr>
  <td>存入串</td>
  <td>STOSB  /  STOSW</td>
  <td>REPE  /  REPZ</td>
  <td>STD</td>
</tr>
<tr>
  <td>从串取</td>
  <td>LODSB  /  LODSW</td>
  <td>REPNE  /  REPNZ</td>
  <td></td>
</tr>
<tr>
  <td>串比较</td>
  <td>CMPSB  /  CMPSW</td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td>串扫描</td>
  <td>SCASB  /  SCASW</td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td>串输入</td>
  <td>INSB / INSW</td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td>串输出</td>
  <td>OUTSB / OUTSW</td>
  <td></td>
  <td></td>
</tr>
</tbody></table>


<p>说明：</p>

<p>　　字符串操作指令的实质是对一片连续存储单元进行处理，这片存储单元是由<font color="blue">隐含指针DS:SI或ES:DI</font>来指定的。</p>



<h3 id="rep">REP</h3>

<p>　　与 <code>REP</code> 配合工作的<code>MOVS / STOS / LODS / INS / OUTS</code>。 <br>
　　<code>REP</code> 重复串操作直到计数寄存器CX的内容为0为止。 <br>
　　执行操作：</p>

<ul>
<li>1)   如 (CX)=0 则退出 REP，否则转(2)</li>
<li>2)   (CX) &lt;- (CX) -1</li>
<li>3)   执行 MOVS / STOS / LODS / INS / OUTS</li>
<li>4)   重复 (1) ~ (3)</li>
</ul>



<h3 id="movs串传送指令">MOVS串传送指令</h3>

<p>　　MOVS 串传送指令：</p>



<pre class="prettyprint"><code class="language-asm hljs ">MOVS    DST, SRC
MOVSB ;（字节）
MOVSW ;（字）
MOVSD ;（双字，计数器为ECX，386及后继机型）</code></pre>

<p>　　例：<code>MOVS  ES: BYTE PTR [DI],  DS: [SI]</code> <br>
　　执行操作：</p>

<ul>
<li>1) <code>((DI)) ← ((SI))</code></li>
<li>2)  字节操作：<code>(SI)←(SI)±1,  (DI)←(DI)±1</code>，字操作： <code>(SI)←(SI)±2,  (DI)←(DI)±2</code> <br>
<ul><li>（方向标志  DF=0 时用 + ，DF=1 时用 - 。）</li></ul></li>
</ul>

<hr>

<p>　　<code>REP MOVS</code>：将数据段中的整串数据传送到附加段中。<code>源串（数据段）→ 目的串（附加段）</code> <br>
　　执行 REP MOVS 之前，应先做好：</p>

<ul>
<li>1)    源串首地址（末地址）→ <code>SI</code></li>
<li>2)    目的串首地址（末地址）→ <code>DI</code></li>
<li>3)    串长度 → <code>CX</code></li>
<li>4)    建立方向标志<code>CLD ( STD )</code> <br>
<ul><li>CLD 使 DF=0，从前往后处理，地址自动增量；</li>
<li>STD 使 DF=1 ，由后向前处理，地址自动减量) <br>
<img src="http://img.blog.csdn.net/20170605195944819?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></li></ul></li>
</ul>

<h4 id="代码实例">代码实例</h4>



<pre class="prettyprint"><code class="language-asm hljs haskell">; <span class="hljs-comment">-------- 定义数据段</span>
<span class="hljs-typedef"><span class="hljs-keyword">data</span>   segment</span>
       mess1  db  ‘personal_computer’
<span class="hljs-typedef"><span class="hljs-keyword">data</span>   ends</span>
; <span class="hljs-comment">-------- 定义附加段</span>
<span class="hljs-title">extra</span>  segment
       mess2  db  <span class="hljs-number">17</span> dup (?)
<span class="hljs-title">extra</span>  ends

<span class="hljs-title">code</span>   segment
<span class="hljs-title">assume</span> cs:code,ds:<span class="hljs-typedef"><span class="hljs-keyword">data</span>.es:extra </span>
 mov  ax, <span class="hljs-typedef"><span class="hljs-keyword">data</span></span>
 mov    ds,ax
 mov    ax, extra
 mov  es, ax
 ; <span class="hljs-comment">------ 总共5条指令。</span>
 lea  si, mess1
 lea  di, mess2
 mov  cx, <span class="hljs-number">17</span>
 cld
 rep  movsb 
 …
<span class="hljs-title">code</span>   ends</code></pre>

<p>　　反向的指令：</p>

<pre class="prettyprint"><code class="language-asm hljs avrasm">lea  si, mess1+<span class="hljs-number">16</span>
lea  di, mess2+<span class="hljs-number">16</span>
<span class="hljs-keyword">mov</span>  cx, <span class="hljs-number">17</span>
<span class="hljs-keyword">std</span>
rep  movsb</code></pre>

<p>　　为了在同一段内处理数据，可以在DS和ES中设置同样的地址。</p>

<pre class="prettyprint"><code class="language-asm hljs haskell"><span class="hljs-typedef"><span class="hljs-keyword">data</span>   segment</span>
 mess1 db  ‘personal_computer’
  mess2  db    <span class="hljs-number">17</span> dup (?)
<span class="hljs-typedef"><span class="hljs-keyword">data</span>   ends</span>

<span class="hljs-title">code</span>   segment
 mov  ax, <span class="hljs-typedef"><span class="hljs-keyword">data</span></span>
 mov    ds, ax
 mov  es, ax

 lea  si, mess1
 lea  di, mess2
 mov  cx, <span class="hljs-number">17</span>
 cld
 rep  movsb
 …
<span class="hljs-title">code</span>   ends</code></pre>

<h2 id="stos存入指令">STOS存入指令</h2>



<pre class="prettyprint"><code class="language-asm hljs ">STOS    DST
STOSB        （字节）
STOSW       （字）</code></pre>

<p>　　执行操作： <br>
　　字节操作：<code>((DI))←(AL),  (DI)←(DI)±1</code> <br>
　　字操作：<code>((DI))←(AX),  (DI)←(DI)±2</code> <br>
　　例：把 附加段 中mess2开始的 10 个字节缓冲区全部置为 20H</p>

<pre class="prettyprint"><code class="language-asm hljs avrasm">lea  di, mess2
<span class="hljs-keyword">mov</span>  al, <span class="hljs-number">20</span>H
<span class="hljs-keyword">mov</span>  cx, <span class="hljs-number">10</span>
cld
rep  stosb</code></pre>

<p>　　或者：</p>

<pre class="prettyprint"><code class="language-asm hljs avrasm">lea  di, mess2
<span class="hljs-keyword">mov</span>  ax, <span class="hljs-number">2020</span>H
<span class="hljs-keyword">mov</span>  cx, <span class="hljs-number">5</span>
cld
rep  stosw
</code></pre>

<h2 id="lods从串取指令">LODS从串取指令</h2>



<pre class="prettyprint"><code class="language-asm hljs ">LODS SRC
LODSB ;（字节）
LODSW ;（字）</code></pre>

<p>执行操作：   </p>

<ul>
<li>字节操作：(AL)←((SI)),  (SI)←(SI)±1</li>
<li>字操作：(AX)←((SI)),  (SI)←(SI)±2</li>
</ul>

<p>注意:  </p>

<ul>
<li>LODS 指令一般不与 REP 联用；</li>
<li>有时缓冲区中的一串字符需要逐次取出来测试，可使用本指令。</li>
</ul>

<h2 id="ins-串输入指令">INS 串输入指令：</h2>



<pre class="prettyprint"><code class="language-asm hljs ">INS   DST, DX
INSB  ; (字节）
INSW  ;（字）</code></pre>

<p>执行操作： <br>
　　字节操作：<code>((DI))←（(DX)）,  (DI)←(DI)±1</code> <br>
　　字操作：<code>((DI))←（(DX)）,  (DI)←(DI)±2</code>功能：把端口号在DX的I/O空间的字节、字或双字传送到附加段中的由DI所指向的存储单元中，并根据DF的值和数据类型修改DI的内容。</p>

<pre class="prettyprint"><code class="language-asm hljs avrasm"><span class="hljs-comment">; 从0F03H端口输入10个字符到mess1字节缓冲区</span>
lea  di, mess1
<span class="hljs-keyword">mov</span>  dx, <span class="hljs-number">0</span>F03H
<span class="hljs-keyword">mov</span>  cx, <span class="hljs-number">10</span>
cld
rep  insb</code></pre>

<h2 id="outs-串输出指令">OUTS 串输出指令：</h2>



<pre class="prettyprint"><code class="language-asm hljs ">OUTS   DX  , SRC
OUTSB  ;（字节）
OUTSW  ;（字）</code></pre>

<p>执行操作： <br>
　　字节操作：<code>((DX))←（(SI)）,  (SI)←(SI)±1</code> <br>
　　字操作：<code>((DX))←（(SI)）,  (SI)←(SI)±2</code> <br>
　　功能：把由SI所指向的存储单元中的字节、字或双字传送到端口号在DX的I/O端口中去，并根据DF的值和数据类型修改SI的内容。</p>

<pre class="prettyprint"><code class="language-asm hljs avrasm"><span class="hljs-comment">; -------- 把mess1字节缓冲区中的10个字符从0F03H端口输出</span>
lea  si, mess1
<span class="hljs-keyword">mov</span>  dx, <span class="hljs-number">0</span>F03H
<span class="hljs-keyword">mov</span>  cx, <span class="hljs-number">10</span>
cld
rep  outsb</code></pre>

<p>与 REPE / REPZ（REPNE / REPNZ）配合工作的 <br>
     CMPS 和 SCAS</p>

<table>
<thead>
<tr>
  <th>指令</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>REPE / REPZ</td>
  <td>当相等 /为零时重复串操作</td>
</tr>
<tr>
  <td>REPNE / REPNZ</td>
  <td>当不相等 /不为零时重复串操作</td>
</tr>
</tbody></table>


<p>执行操作：</p>

<ul>
<li>1) 如 <code>(CX)=0</code> 或 <code>ZF=0 (ZF=1)</code> 则退出串操作，否则转2)</li>
<li>2) <code>(CX)←(CX) -1</code></li>
<li>3)  执行 <code>CMPS / SCAS</code></li>
<li>4)  重复 (1) ~ (3)</li>
</ul>

<h2 id="cmps-串比较指令">CMPS 串比较指令：</h2>



<pre class="prettyprint"><code class="language-asm hljs ">CMPS    SRC, DST
CMPSB  ;（字节）
CMPSW  ;（字）</code></pre>

<p>执行操作：</p>

<ul>
<li>1) <code>((SI)) - ((DI))</code>根据比较结果置条件标志位：相等 ZF=1,不等 ZF=0</li>
<li><p>2) 字节操作：<code>(SI)←(SI)±1,  (DI)←(DI)±1</code>，字操作： <code>(SI)←(SI)±2,  (DI)←(DI)±2</code></p>

<p>　　汇编语言中，CMP和CMPS都是比较指令，不同主要有： <br>
　　1、CMP比较指令是执行两个数的相减操作，包括有符号数。CMPS比较指令是执行两个字符串的相减操作，所有数据认为是无符号数。 <br>
　　2、CMP比较指令必须有两个显式操作数。CMPS比较指令可以有两个显式操作数，也可以使用指令CMPSB或CMPSW分别表示字节串比较或字串比较而隐含操作数。 <br>
　　3、使用CMP比较指令比较连续的数据时，必须由程序改变其中一个操作数。使用CMPS比较指令比较连续的字符时，对由SI寻址的源串中数据与由DI寻址的目的串中数据进行比较，执行完一条比较指令，SI，DI将自动调整.</p></li>
</ul>

<h2 id="repe">REPE</h2>

<p>　　例：比较两个字符串，找出它们不相匹配的位置。</p>



<pre class="prettyprint"><code class="language-asm hljs avrasm">lea   si, mess1
lea   di, mess2
<span class="hljs-keyword">mov</span>   cx, <span class="hljs-number">5</span>
cld
repe  cmpsb</code></pre>

<p><img src="http://img.blog.csdn.net/20170605221841174?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br>
　　反向比较：</p>

<pre class="prettyprint"><code class="language-asm hljs avrasm">lea   si, mess1+<span class="hljs-number">4</span>
lea   di, mess2+<span class="hljs-number">4</span>
<span class="hljs-keyword">mov</span>   cx, <span class="hljs-number">5</span>
<span class="hljs-keyword">std</span>
repe   cmpsb</code></pre>

<h2 id="scas-串扫描指令">SCAS 串扫描指令</h2>



<pre class="prettyprint"><code class="language-asm hljs ">SCAS DST
SCASB （字节）
SCASW （字）</code></pre>

<p>执行操作： <br>
　　字节操作：<code>(AL) - ((DI)),  (DI)←(DI)±1</code> <br>
　　字操作：<code>(AX) - ((DI)),  (DI)←(DI)±2</code></p>

<p>例：从一个字符串中查找一个指定的字符</p>

<pre class="prettyprint"><code class="language-asm hljs brainfuck"> <span class="hljs-comment">mess</span>  <span class="hljs-comment">db</span>  <span class="hljs-comment">‘COMPUTER’</span>

 <span class="hljs-comment">lea</span>   <span class="hljs-comment">di</span><span class="hljs-string">,</span> <span class="hljs-comment">mess</span> <span class="hljs-comment">;</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span> <span class="hljs-comment">(ES:DI)保留串地址</span>
 <span class="hljs-comment">mov</span>   <span class="hljs-comment">al</span><span class="hljs-string">,</span> <span class="hljs-comment">‘T’</span>  <span class="hljs-comment">;</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span> <span class="hljs-comment">搜索字符</span>
 <span class="hljs-comment">mov</span>   <span class="hljs-comment">cx</span><span class="hljs-string">,</span> <span class="hljs-comment">8</span>    <span class="hljs-comment">;</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span> <span class="hljs-comment">字符长度</span>
 <span class="hljs-comment">cld</span>
 <span class="hljs-comment">repne</span> <span class="hljs-comment">scasb</span> <span class="hljs-comment">;</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span> <span class="hljs-comment">这里在循环的判断是否(CX)=0或ZF=1。条件成立即中止</span></code></pre>

<p>执行完后</p>

<ul>
<li>(di)：相匹配字符的下一个地址</li>
<li>(cx)：剩下还未比较的字符个数</li>
</ul>

<h1 id="子程序设计">子程序设计</h1>



<pre class="prettyprint"><code class="language-C++ hljs go"><span class="hljs-typename">int</span> i<span class="hljs-number">=0</span>;
<span class="hljs-typename">int</span> main(){
    <span class="hljs-keyword">func</span>();
   <span class="hljs-keyword">return</span><span class="hljs-number"> 0</span>;
}
void <span class="hljs-keyword">func</span>(){
    i++;
}</code></pre>

<p>　　等价于：</p>



<pre class="prettyprint"><code class="language-asm hljs avrasm">ASSUME CS:CODE
CODE SEGMENT
<span class="hljs-label">START:</span>
     <span class="hljs-keyword">MOV</span> AX,<span class="hljs-number">0</span>               <span class="hljs-comment">;AX相当于i</span>
     <span class="hljs-keyword">CALL</span> FUNC              <span class="hljs-comment">;调用FUNC子程序</span>
     <span class="hljs-keyword">MOV</span> AH,<span class="hljs-number">4</span>CH
     INT <span class="hljs-number">21</span>H
FUNC PROC  NEAR
     <span class="hljs-keyword">INC</span> AX                      <span class="hljs-comment">;i++</span>
     <span class="hljs-keyword">RET</span>
FUNC ENDP
CODE ENDS
END  START</code></pre>

<p>　　<strong>子程序:</strong>在许多应用程序中，常常需要多次使用某功能的指令序列。这时，<font color="blue">为了减少重复编写程序，节省内存空间</font>，把这一功能的指令序列组成一个相对独立的程序段。在程序运行时，如果需要使用这个给定的功能，就转移到这个独立的程序段，待这个独立的程序段指令序列执行完后，又返回到原来位置继续运行程序。我们把这个相对独立的程序段就叫<font color="blue">子程序</font>或<font color="blue">过程</font>。 <br>
　　<strong>调用程序:</strong>编制程序时，按需要转向子程序，称为<font color="blue">子程序调用</font>，或称为<font color="blue">过程调用</font>。调用子程序的程序称为调用程序或主程序。主、子程序是相对而言的。但子程序一定是受调用程序或主程序调用的。子程序定义的位置可以放在主程序的前面或后面。</p>

<h2 id="过程定义伪操作">过程定义伪操作</h2>



<pre class="prettyprint"><code class="language-asm hljs delphi">过程名 PROC <span class="hljs-keyword">NEAR</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">FAR</span>
    ……
    RET
过程名 ENDP</code></pre>

<p>说明：</p>

<ul>
<li>过程名是子程序入口的符号地址；</li>
<li>RET是子程序返回的命令；</li>
<li>NEAR属性：调用程序和子程序在同一代码段中，可省略。（段内调用）</li>
<li>FAR属性：调用程序和子程序不在同一代码段中。（段间调用）</li>
<li><font color="red">同一个子程序可以被段内调用，也可以段间调用。</font></li>
</ul>

<h2 id="子程序的调用与返回指令">子程序的调用与返回指令</h2>



<h3 id="1call-子程序调用指令隐含使用堆栈保存返回地址">1）CALL 子程序调用指令：隐含使用堆栈保存返回地址</h3>

<p>　　指令格式：<code>CAL DST  ;其中DST为过程的目标地址（即过程名）</code>。 <br>
　　指令功能：</p>

<ul>
<li>把CALL指令的下一条指令地址（称为返回点或断点） 推入堆栈保存，然后转到目标地址（DST）。</li>
<li>CALL指令可以在段内、段间调用，寻址方式分为直接和间接两种。</li>
</ul>



<h4 id="段内直接近调用call-dst">段内直接近调用：<code>CALL DST</code></h4>

<p>　　DST给出子程序的入口地址（子程序为near属性），比如：<code>CALL subp</code></p>

<p>　　执行操作：</p>

<ul>
<li>(SP) ← (SP) - 2</li>
<li>( (SP)+1,(SP) ) ← (IP) <br>
<ul><li>上面两句相当于<code>PUSH IP</code></li></ul></li>
<li>(IP) ← DST <br>
<ul><li>实际操作是把从指令中得到的距目标过程相对偏移量加到指令指针IP上（得到子程序的入口地址），实现过程调用。</li></ul></li>
</ul>



<h4 id="段内间接近调用call-dst">段内间接近调用：<code>CALL DST</code></h4>

<p>　　执行操作： </p>

<ul>
<li><code>PUSH IP</code></li>
<li>(IP) ← (EA) <br>
<ul><li>DST给出寄存器或存储单元的内容（转向地址）</li>
<li>比如： CALL word ptr [bx]</li></ul></li>
</ul>



<h4 id="段间直接远调用call-far-ptr-dst">段间直接远调用：<code>CALL FAR PTR DST</code></h4>

<p>　　DST给出子程序的入口地址（子程序为far属性），比如：<code>CALL far ptr subp</code></p>

<p>　　执行操作：   </p>

<ul>
<li><code>PUSH CS</code></li>
<li><code>PUSH IP</code></li>
<li>(IP) ← DST偏移地址</li>
<li>(CS) ← DST段地址</li>
</ul>



<h4 id="段间间接远调用call-far-ptr-dst">段间间接远调用：<code>CALL FAR PTR DST</code></h4>

<p>　　DST给出存储单元的内容（转向地址），比如： <code>CALL dword ptr [bx]</code> <br>
　　执行操作：  </p>

<ul>
<li><code>PUSH CS</code></li>
<li><code>PUSH IP</code></li>
<li>(IP) ← (EA)</li>
<li>(CS) ← (EA+2)</li>
</ul>



<h3 id="2ret-返回主程序指令">2）RET 返回主程序指令</h3>

<p>　　说明：属于无条件转移指令。可以在段内或段间返回。</p>



<h4 id="段内近返回ret">段内近返回：<code>RET</code></h4>

<p>　　执行操作：</p>

<ul>
<li><code>POP IP</code></li>
</ul>



<h4 id="段内带立即数近返回ret-exp">段内带立即数近返回：<code>RET EXP</code></h4>

<p>　　执行操作： </p>

<ul>
<li><code>POP   IP</code></li>
<li><code>(SP)←(SP)+EXP</code></li>
</ul>



<h4 id="段间远返回retf">段间远返回：<code>RET（F）</code></h4>

<p>　　执行操作：</p>

<ul>
<li><code>POP IP</code></li>
<li><code>POP CS</code>                </li>
</ul>



<h2 id="现场保护和恢复">现场保护和恢复</h2>

<p>　　要保护的寄存器：应该是在子程序中将被使用，返回调用程序后仍然需要使用其原有内容的那些寄存器。即保护调用程序和子程序两者在使用上发生冲突的那些寄存器。<font color="blue">但在编程时，一时很难弄清哪些是有冲突的寄存器，一种较为简单的方法是把所有的寄存器均加以保护。</font> <br>
　　一般在子程序中进行寄存器保护较好。即在子程序的开始部分，先进行相关寄存器（主要是在子程序中使用的各寄存器）的保护。然后再进行子程序的处理操作。<font color="blue">在执行完子程序后，返回前，先恢复各寄存器内容后，再返回调用程序。</font></p>



<pre class="prettyprint"><code class="language-asm hljs avrasm">subt   proc   near 
        <span class="hljs-keyword">push</span>    ax
        <span class="hljs-keyword">push</span>    bx
        <span class="hljs-keyword">push</span>    cx
        <span class="hljs-keyword">push</span>    dx
        ……
        ……
        <span class="hljs-keyword">pop</span>     dx
        <span class="hljs-keyword">pop</span>     cx
        <span class="hljs-keyword">pop</span>     bx
        <span class="hljs-keyword">pop</span>     ax

        <span class="hljs-keyword">ret</span>
subt   endp</code></pre>

<h2 id="子程序的参数传送">子程序的参数传送</h2>

<p>　　入口参数：子程序需要从主程序获取的参数。使子程序可以对不同数据进行相同功能的处理。 <br>
　　出口参数：是子程序返回给主程序的参数。使子程序可以将不同的结果送至主程序</p>

<p>　　实现的方法是把子程序所需要的入口参数，由调用程序预先放入指定的寄存器中。在进入子程序后，子程序就可直接对这些寄存器内容进行操作了。同样子程序的运行结果，也可置入寄存器中，把它们作为子程序的出口参数寄存器使用。由于寄存器数目有限，适用于参数较少的情况。</p>

<ul>
<li>1) 通过寄存器传送参数</li>
<li>2) 通过存储器传送参数</li>
<li>3) 通过地址表传送参数地址</li>
<li>4) 通过堆栈传送参数或参数地址</li>
</ul>

<hr>

<p>　　参数的传递方法并不是固定不变的，即它们是可以综合使用的。依实现的需要和情况的不同，可以灵活使用其中一种方式，也可以同时使用几种方式的混合。有的时候还可能并不需要参数传递。</p>



<pre class="prettyprint"><code class="language-asm hljs avrasm"><span class="hljs-comment">; 十六进制到十进制的转换（通过寄存器传送参数）</span>
<span class="hljs-comment">; hexidec：接收键盘输入的十六进制数，在屏幕上输出相应的十进制数</span>
hexidec  segment             <span class="hljs-comment">; 1610</span>
    assume cs: hexidec 
main     proc   far
<span class="hljs-label">start:</span>   
    <span class="hljs-keyword">push</span>   ds
    <span class="hljs-keyword">sub</span>    ax, ax
    <span class="hljs-keyword">push</span>   ax

    <span class="hljs-keyword">call</span>   hexibin      <span class="hljs-comment">; 16转2</span>
    <span class="hljs-keyword">call</span>   crlf
    <span class="hljs-keyword">call</span>   binidec      <span class="hljs-comment">; 2转10</span>
    <span class="hljs-keyword">call</span>   crlf

    <span class="hljs-keyword">ret</span>
main     endp
    ……
    ……
    ……
hexidec  ends

<span class="hljs-comment">; 按位取数</span>
binidec  proc  near 
    <span class="hljs-keyword">mov</span>   cx, <span class="hljs-number">10000</span>d
    <span class="hljs-keyword">call</span>  dec_div
    <span class="hljs-keyword">mov</span>   cx, <span class="hljs-number">1000</span>d
    <span class="hljs-keyword">call</span>  dec_div
    <span class="hljs-keyword">mov</span>   cx, <span class="hljs-number">100</span>d
    <span class="hljs-keyword">call</span>  dec_div
    <span class="hljs-keyword">mov</span>   cx, <span class="hljs-number">10</span>d
    <span class="hljs-keyword">call</span>  dec_div
    <span class="hljs-keyword">mov</span>   cx, <span class="hljs-number">1</span>d
    <span class="hljs-keyword">call</span>  dec_div
    <span class="hljs-keyword">ret</span>

binidec  endp

dec_div  proc  near
    <span class="hljs-keyword">mov</span>   ax, bx
    <span class="hljs-keyword">mov</span>   dx, <span class="hljs-number">0</span>
    div   cx
    <span class="hljs-keyword">mov</span>   bx, dx
    <span class="hljs-keyword">mov</span>   dl, al
    <span class="hljs-keyword">add</span>   dl, <span class="hljs-number">30</span>h
    <span class="hljs-keyword">mov</span>   ah, <span class="hljs-number">2</span>
    int   <span class="hljs-number">21</span>h
    <span class="hljs-keyword">ret</span>
dec_div  endp

<span class="hljs-comment">; hexibin:接收4位十六进制数的输入</span>
<span class="hljs-comment">; binidec:输出5位的十进制数值</span>
<span class="hljs-comment">; 入口参数为BX。</span>
<span class="hljs-comment">; 出口参数为BX。</span>
hexibin   proc  near 

    <span class="hljs-keyword">mov</span>   bx, <span class="hljs-number">0</span>
    <span class="hljs-keyword">mov</span>   cx,<span class="hljs-number">4</span>

<span class="hljs-label">newchar:</span>
    <span class="hljs-keyword">mov</span>   ah, <span class="hljs-number">1</span>
    int   <span class="hljs-number">21</span>h
    cmp   al, <span class="hljs-number">30</span>h    <span class="hljs-comment">; 0~9的16进制表示为30~39</span>
    jl    exit
    cmp   al, <span class="hljs-number">3</span>ah     <span class="hljs-comment">; 和10比较，如果小于10的就跳转到add_to</span>
    jl    add_to

    cmp   al, <span class="hljs-number">41</span>h     <span class="hljs-comment">; 和A比较</span>
    jl    exit
    cmp   al, <span class="hljs-number">47</span>h     <span class="hljs-comment">; 和G比较</span>
    jge   exit

    cmp   al, <span class="hljs-number">61</span>h     <span class="hljs-comment">; 和a比较</span>
    jl    exit
    cmp   al, <span class="hljs-number">67</span>h     <span class="hljs-comment">; 和g比较</span>
    jge   exit
<span class="hljs-label">add_to:</span>
    <span class="hljs-keyword">push</span>  cx
    <span class="hljs-keyword">mov</span>   cl, <span class="hljs-number">4</span>
    shl   bx, cl
    <span class="hljs-keyword">mov</span>   ah, <span class="hljs-number">0</span>
    <span class="hljs-keyword">add</span>   bx, ax
    <span class="hljs-keyword">pop</span>   cx
    loop  newchar
<span class="hljs-label">exit:</span>   
    <span class="hljs-keyword">ret</span>
hexibin   endp

<span class="hljs-comment">; 回车换行</span>
Crlf   proc near
   <span class="hljs-keyword">push</span> ax
   <span class="hljs-keyword">push</span> dx
   <span class="hljs-keyword">mov</span> dl, <span class="hljs-number">0</span>dh
   <span class="hljs-keyword">mov</span> ah,<span class="hljs-number">2</span>
   int    <span class="hljs-number">21</span>h
   <span class="hljs-keyword">mov</span> dl, <span class="hljs-number">0</span>ah
   <span class="hljs-keyword">mov</span>  ah,<span class="hljs-number">2</span>
   int    <span class="hljs-number">21</span>h
   <span class="hljs-keyword">pop</span>  dx
   <span class="hljs-keyword">pop</span>  ax
   <span class="hljs-keyword">ret</span>
Crlf    endp
    end    start</code></pre>

<h1 id="宏">宏</h1>

<p>　　宏：源程序中一段有独立功能的程序代码。在使用之前先定义一次，以后就可以多次调用。 <br>
　　宏指令：用户自定义的指令。在编程时，将多次使用的功能用一条宏指令来代替。 </p>

<p>汇编语言源程序包含：</p>

<ul>
<li>指令：程序运行时执行的语句</li>
<li>伪指令（伪操作）：汇编时执行</li>
<li>宏指令：汇编时展开</li>
</ul>



<h2 id="高级语言的宏">高级语言的宏</h2>

<p>　　C语言中以#define作为标志的编译预处理命令称为宏定义命令。其不带参数的格式为： <br>
　　</p>



<pre class="prettyprint"><code class=" hljs cs"> <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> 标识符 字符串</span></code></pre>

<p>　　其中的标识符叫宏名，字符串叫宏体。带参的宏一般形式为： <br>
　　</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span>  宏名（参数表）  字符串</span></code></pre>

<p>　　如：</p>



<pre class="prettyprint"><code class="language-C hljs cs"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span>  PI  3.1415926</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span>  area(r) (3.1415926*(r)*(r))</span></code></pre>

<p>　　系统对宏的处理是这样的：<font color="blue">当遇到宏名时，就用宏体替换，即所谓的宏替换。</font>这一过程是由预编译程序完成的（不必用户自己操作），而后才将宏替换后的程序交编译程序进行编译。</p>



<h2 id="宏定义宏调用和宏展开">宏定义、宏调用和宏展开</h2>



<pre class="prettyprint"><code class="language-asm hljs cmake">; 宏定义：               
macro_name   <span class="hljs-keyword">MACRO</span>  [哑元表] ; 形参/虚参
    …… 
    ……              ; 宏定义体
ENDM</code></pre>

<p>　　宏调用： （必须先定义后调用）<code>macro_name  [实元表]       ; 实参</code> <br>
 　　宏展开： 宏定义体-&gt;复制到宏指令位置,实参代虚参。</p>

<h2 id="宏和子程序的对比">宏和子程序的对比</h2>

<table>
<thead>
<tr>
  <th>名称</th>
  <th>优点</th>
  <th>缺点</th>
</tr>
</thead>
<tbody><tr>
  <td>子程序</td>
  <td>模块化，省内存</td>
  <td>开销大</td>
</tr>
<tr>
  <td>宏</td>
  <td>参数传送简单，执行效率高</td>
  <td>占用内存空间大</td>
</tr>
</tbody></table>




<h2 id="宏定义中的参数">宏定义中的参数</h2>

<ul>
<li>1、宏定义可以无变元（无参数）；</li>
<li>2、变元可以是常数、寄存器、存储单元名以及用寻址方式能找到的地址或表达式；</li>
<li>3、变元可以是操作码或操作码的一部分（必须用&amp;作为分隔符）；</li>
<li>4、变元可以是ASCII串（字符串）。 <br>
<ul><li><font color="blue">注意：宏调用时若实参个数少于形参个数会出现编译错误，若实参个数多于形参，则按形参的顺序填入实参，多余部分被忽略。</font></li></ul></li>
</ul>



<h2 id="宏汇编操作符">宏汇编操作符</h2>

<table>
<thead>
<tr>
  <th>符号</th>
  <th>使用</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td><code>&amp;</code></td>
  <td>符号1 &amp; 符号2</td>
  <td>宏展开时,合并前后两个符号形成一个符号。 &amp;可以作为哑元的前缀。</td>
</tr>
<tr>
  <td><code>;;</code></td>
  <td></td>
  <td>宏展开的时候，<code>;;</code>后面的注释不予展开。</td>
</tr>
<tr>
  <td><code>%</code></td>
  <td>% 表达式</td>
  <td>汇编程序将%后面的表达式转换为当前基数下的数字，并在展开期间用这个数取代哑元。</td>
</tr>
</tbody></table>




<h2 id="local伪操作">LOCAL伪操作</h2>

<p>　　LOCAL伪操作为每个标号建立唯一的符号（??0000~??FFFF）,必须紧跟在MACRO语句之后，中间不允许有任何操作包括注释。</p>



<pre class="prettyprint"><code class="language-asm hljs lua">; 宏定义
absol  MACRO  oper
       LOCAL  <span class="hljs-built_in">next</span>
       cmp  oper,<span class="hljs-number">0</span>
       jge  <span class="hljs-built_in">next</span>
       neg  oper
<span class="hljs-built_in">next</span>:  
       ENDM
; 宏调用
……
absol  var
……
absol  bx
……</code></pre>

<p>　　说明： <br>
　　反汇编出来内容如下： <br>
　　</p>

<pre class="prettyprint"><code class="language-asm hljs coffeescript">宏展开：
        ……; `<span class="javascript">absol <span class="hljs-keyword">var</span></span>`的内容
<span class="hljs-number">1</span>       cmp  <span class="hljs-reserved">var</span>,<span class="hljs-number">0</span>
<span class="hljs-number">1</span>       jge  ??<span class="hljs-number">0000</span>
<span class="hljs-number">1</span>       neg  <span class="hljs-reserved">var</span>
<span class="hljs-number">1</span> ??<span class="hljs-number">0000</span>:   ; next的地址
        ……

        ……; `<span class="javascript">absol bx</span>`的内容
<span class="hljs-number">1</span>       cmp  bx,<span class="hljs-number">0</span>
<span class="hljs-number">1</span>       jge  ??<span class="hljs-number">0001</span>
<span class="hljs-number">1</span>       neg  bx
<span class="hljs-number">1</span> ??<span class="hljs-number">0001</span>:   ; next的地址
        ……</code></pre>

<p>　　从上面可以看出使用了LOCAL伪操作之后，每次调用absol后，next的地址都是不同的。即<font color="red">　LOCAL伪操作为每个标号建立唯一的符号</font>。</p>

<h2 id="列表伪操作">列表伪操作</h2>

<table>
<thead>
<tr>
  <th>名称</th>
  <th>说明</th>
</tr>
</thead>
<tbody><tr>
  <td>.LALL</td>
  <td>在LST清单中列出宏展开后的全部语句(包括注释)。</td>
</tr>
<tr>
  <td>.SALL</td>
  <td>在LST清单中不列出任何宏展开后的语句。</td>
</tr>
<tr>
  <td>.XALL</td>
  <td>缺省的列表方式，只列出宏体中产生目标代码的语句。</td>
</tr>
</tbody></table>




<h2 id="宏库的建立和调用">宏库的建立和调用</h2>



<h3 id="建立宏库">建立宏库</h3>

<p>　　<code>&gt;EDIT   MACRO . MAC</code> <br>
　　</p>



<pre class="prettyprint"><code class="language-asm hljs css"><span class="hljs-tag">macro1</span>  <span class="hljs-tag">MACRO</span>   <span class="hljs-attr_selector">[哑元表]</span>
        ……     
        <span class="hljs-tag">ENDM</span> 

<span class="hljs-tag">macro2</span>  <span class="hljs-tag">MACRO</span>   <span class="hljs-attr_selector">[哑元表]</span>
        ……      
        <span class="hljs-tag">ENDM</span>
        ……

<span class="hljs-tag">macroN</span>  <span class="hljs-tag">MACRO</span>   <span class="hljs-attr_selector">[哑元表]</span>
        ……      
        <span class="hljs-tag">ENDM</span>
</code></pre>

<h2 id="调用宏库">调用宏库</h2>

<p>　　<code>&gt;EDIT EXP.ASM</code></p>



<pre class="prettyprint"><code class="language-asm hljs css"><span class="hljs-tag">include</span>  <span class="hljs-tag">MACRO</span><span class="hljs-class">.MAC</span>
……
<span class="hljs-tag">macro1</span>  <span class="hljs-attr_selector">[实元表]</span>
……
<span class="hljs-tag">macro2</span>  <span class="hljs-attr_selector">[实元表]</span>
……          ; 删除不用的宏定义`<span class="hljs-tag">purge</span> <span class="hljs-tag">macroN</span>`
<span class="hljs-tag">macroN</span>  <span class="hljs-attr_selector">[实元表]</span>
……</code></pre>

<h1 id="输入输出程序设计">输入输出程序设计</h1>

<p>　　不同外设具有的端口数各不相同，计算机中为每一个端口都赋予一个惟一编号——称为端口地址(或端口号PORT)。 8086CPU采用I/O端口独立编址的方式，采用16位地址最多能管理<font color="blue">64K个端口</font>,即端口占64KB地址空间，端口号为<font color="blue">0~65535</font>。必须使用专门的I/O指令访问端口。 <br>
　　CPU与I/O接口进行通信是通过接口电路内部的一组寄存器实现的，这些寄存器称为端口，包括：<font color="blue">数据端口、状态端口和命令端口</font>。</p>



<h2 id="累加器专用传送指令inout">累加器专用传送指令IN/OUT</h2>

<p>（只能用AX或AL与端口传送信息）</p>



<h3 id="输入指令">输入指令</h3>

<ul>
<li>IN   （I/O -&gt; CPU）    </li>
</ul>

<p>长格式：(<font color="blue">PORT是端口地址(00~FFH)</font>)     </p>

<ul>
<li>IN   AL, PORT   （字节）</li>
<li>IN   AX, PORT   （字）</li>
</ul>

<p>执行操作：</p>

<ul>
<li>(AL)  &lt;-  ( PORT )  （字节）</li>
<li>(AX)  &lt;-  ( PORT+1,  PORT )（字）</li>
</ul>

<p>短格式：   </p>

<ul>
<li>MOV   DX,  PORT</li>
<li>IN   AL, DX   （字节）</li>
<li>IN   AX, DX   （字）</li>
</ul>

<p>执行操作：(<font color="blue">端口号&gt;255时，先送到DX</font>)</p>

<ul>
<li>(AL)  &lt;-  ( (DX) )    （字节）</li>
<li>(AX)  &lt;-  ( (DX)+1,  (DX) )（字） </li>
</ul>



<h3 id="输出指令">输出指令</h3>

<ul>
<li>OUT   （CPU -&gt; I/O）</li>
</ul>

<p>长格式：    </p>

<ul>
<li>OUT   PORT, AL  （字节）</li>
<li>OUT   PORT, AX  （字）</li>
</ul>

<p>功能：将寄存器中内容输出到指定端口。</p>

<p>短格式：    </p>

<ul>
<li>MOV DX , PORT</li>
<li>OUT   DX, AL  （字节）</li>
<li>OUT   DX, AX  （字）</li>
</ul>



<h2 id="访问端口">访问端口</h2>

<p>　　<code>in al,60h;</code>从60h号端口读入一个字节。 <br>
　　执行时与总线相关的操作：</p>

<ul>
<li>① CPU通过地址线将地址信息60h发出；</li>
<li>② CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据；</li>
<li>③ 端口所在的芯片将60h端口中的数据通过数据线送入CPU。 <br>
<ul><li>注意：在in和out 指令中，<font color="blue">只能使用 ax 或al来存放从端口中读入的数据或要发送到端口中的数据</font>。</li></ul></li>
</ul>



<h2 id="io-设备的数据传送方式">I/O 设备的数据传送方式</h2>

<ul>
<li>1、查询方式（程序控制方式）</li>
<li>2 、中断方式</li>
<li>3 、DMA方式（直接存储器存取方式/成组传送方式）</li>
</ul>



<h3 id="查询方式">查询方式</h3>

<p>　　CPU和内存通过端口与外部设备进行通信。CPU在执行主程序过程中，当需要进行I/O操作时，很难保证输入设备已经准备好了数据，或者是输出设备已经处在可以接收数据的状态。因此，一般要在外部设备准备就绪并且I/O接口已经做好数据传送的情况下，才能进行数据传送，这种传送方式称为<font color="blue">查询传送方式</font>。</p>

<p>　　 <img src="http://img.blog.csdn.net/20170605083235751?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br>
　　 <font color="blue">查询过程使CPU很容易与不同速度的外设实现速度配合，使接口电路十分简单</font>，适用于较少数据传输情况下使用。但要<font color="blue">占用CPU大量时间去查询I/O设备的状态</font>。 <br>
　　 </p>



<h3 id="中断传输方式">中断传输方式</h3>

<p><img src="http://img.blog.csdn.net/20170605084225942?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br>
　　  采用中断方式， <font color="blue">CPU执行主程序，等待中断的发生。</font>I/O设备与CPU并行操作，进行数据传输的准备工作。当输入设备将数据准备好，或者输出设备空闲时，便<font color="blue">通过I/O接口向CPU发申请中断。CPU在每执行完一条指令之后都会检查是否有中断请求</font>，只要满足中断响应条件，CPU就暂停执行当前的程序，转向执行中断处理程序，进行数据传送，等传送完成后，CPU返回到被中断的主程序，继续进行原来的工作。  <br>
　　  <font color="red">中断方式</font>：需要保护现场和恢复现场，数据传输由CPU完成。</p>



<h3 id="dma方式成组数据传送方式">DMA方式——成组数据传送方式</h3>

<p>　　主要由硬件DMA控制器实现其传送功能，用于一些高速的I/O设备(比如磁盘)，能使I/O设备直接与存储器进行成批数据的快速传送。 <br>
　　DMA方式：用DMA控制器来控制存储器和I/O设备之间的数据传送时，并不经过CPU，传输过程中CPU不占用总线，CPU处于原地等待。这样，传输时就不需要保存断点等额外操作了。另外，整个控制数据块传送的过程，包括地址增量和计数器减量的操作，都是由硬件控制完成的，因而大大缩短了数据传送的控制时间，提高了整个系统的处理效率。 <br>
<img src="http://img.blog.csdn.net/20170605084811824?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>



<h3 id="程序直接控制-io-方式">程序直接控制 I/O 方式</h3>

<p>　　   I/O 指令是主机与外设进行通信的最基本途径。DOS 功能调用和BIOS例行程序中的输入/输出功能也是由IN和OUT指令完成的。 <br>
　　   例：循环测试某状态寄存器的2位是否为1</p>



<pre class="prettyprint"><code class="language-asm hljs avrasm"><span class="hljs-label">AGAIN:</span> <span class="hljs-keyword">IN</span>  AL, STATUS_PORT<span class="hljs-comment">; --------状态寄存器的端口地址(00~FFH)</span>
           TEST  AL, <span class="hljs-number">00000100</span>B
           JZ    AGAIN
           <span class="hljs-keyword">IN</span>   AL,DATA_PORT<span class="hljs-comment">; --------数据寄存器的端口地址(00~FFH)</span>
           <span class="hljs-keyword">MOV</span>   AL, DATA
           <span class="hljs-keyword">OUT</span>   DATA_PORT, AL</code></pre>

<p>　　<img src="http://img.blog.csdn.net/20170605085407162?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<h3 id="轮流查询几种io设备">轮流查询几种I/O设备</h3>



<pre class="prettyprint"><code class="language-asm hljs avrasm">轮流查询几种I/O设备：
<span class="hljs-label">DEV1:</span>   <span class="hljs-keyword">IN</span>  AL, STAT1
    TEST    AL, STAT1_BIT
    JZ  DEV2
    <span class="hljs-keyword">CALL</span>    FAR PTR PROC1
<span class="hljs-label">DEV2:</span>   <span class="hljs-keyword">IN</span>  AL, STAT2
    TEST    AL, STAT2_BIT
    JZ  DEV3
    <span class="hljs-keyword">CALL</span>    FAR PTR PROC2
<span class="hljs-label">DEV3:</span>   <span class="hljs-keyword">IN</span>  AL, STAT3
    TEST    AL, STAT3_BIT
    JZ  DEV1
    <span class="hljs-keyword">CALL</span>    FAR PTR PROC3</code></pre>

<ul>
<li>优：由程序安排或修改  设备的优先次序</li>
<li>缺：查询等待浪费CPU大量有效时间</li>
<li>使用I/O指令直接控制输入输出比调用DOS功能或BIOS例行程序效率更高，但其<font color="blue">对硬件的依赖性很大</font>，所以一般的程序设计还是尽可能使用DOS或BIOS功能调用。</li>
</ul>

<h3 id="io程序举例-cmos-ram-芯片">I/O程序举例： CMOS RAM 芯片</h3>

<p>　　PC机中有一个CMOS RAM芯片，其有如下特征：</p>

<ul>
<li>1）包含一个<font color="blue">实时钟</font>和一个有<font color="blue">128个存储单元</font>的RAM存储器。</li>
<li>2）该芯片靠电池供电。所以，关机后其内部的实时钟仍可正常工作， RAM 中的信息不丢失。</li>
<li>3）128 个字节的 RAM 中，内部实时钟占用<font color="blue">0～0DH</font>单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序的读取。 <br>
<ul><li>BIOS也提供了相关的程序，使我们可以在开机的时候配置CMOS RAM 中的系统信息。</li></ul></li>
<li>4）该芯片内部有两个端口，端口地址为<font color="blue">70h</font>和<font color="blue">71h</font>。CPU 通过这两个端口读写CMOS RAM。</li>
<li>5）<font color="blue">70h为地址端口</font>，存放要访问的CMOS RAM单元的地址；   <font color="blue">71h为数据端口</font>，存放从选定的CMOS RAM 单元中读取的数据，或要写入到其中的数据。可见，CPU对CMOS RAM的读写分两步进行。 <br>
<ul><li>比如：读CMOS RAM的2号单元： <br>
<ul><li>1、将2送入端口<font color="blue">70h</font> <code>mov  al, 2</code>,<code>out  70h, al</code></li>
<li>2、从<font color="blue">71h</font>读出2号单元的内容<code>in  al, 71h</code></li></ul></li></ul></li>
</ul>



<h3 id="cmos-ram中存储的时间信息">CMOS RAM中存储的时间信息</h3>

<p>　　在CMOS RAM中，存放着当前时间：</p>

<table>
<thead>
<tr>
  <th>类型</th>
  <th>地址</th>
</tr>
</thead>
<tbody><tr>
  <td>秒</td>
  <td>00H</td>
</tr>
<tr>
  <td>分</td>
  <td>02H</td>
</tr>
<tr>
  <td>时</td>
  <td>04H</td>
</tr>
<tr>
  <td>星期</td>
  <td>06H</td>
</tr>
<tr>
  <td>日</td>
  <td>07H</td>
</tr>
<tr>
  <td>月</td>
  <td>08H</td>
</tr>
<tr>
  <td>年</td>
  <td>09H</td>
</tr>
</tbody></table>


<p>　　这6个信息的长度都为1个字节，存储了用两个 BCD码表示的两位十进制数，高 4 位的BCD码表示十位，低4 位的BCD 码表示个位。 <br>
　　<img src="http://img.blog.csdn.net/20170606093806291?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br>
　　比如：00010100b表示14。</p>



<h3 id="读取cmos-ram的信息">读取CMOS RAM的信息</h3>

<p>　　要读取 CMOS RAM的信息，我们首先要向地址端口70h写入要访问的单元的地址：      </p>



<pre class="prettyprint"><code class="language-asm hljs avrasm"><span class="hljs-keyword">mov</span> al,<span class="hljs-number">8</span>  
<span class="hljs-keyword">out</span> <span class="hljs-number">70</span>h,al</code></pre>

<p>　　然后从数据端口71h中取得指定单元中的数据：<code>in al,71h</code></p>

<h1 id="中断传送方式">中断传送方式</h1>

<p>　　<font color="blue">中断</font>：使cpu中止正在执行的程序而转去处理特殊事件的操作。 <br>
　　<font color="blue">中断源</font>：引起中断的事件。8086/8088CPU最多有<font color="blue">256</font>个中断源，这些中断源根据来自CPU的内部还是外部分为两大类：<font color="blue">内部中断源</font>和<font color="blue">外部中断源</font>。 <br>
　　外中断（硬中断）：</p>

<ul>
<li>外设的 I/O 请求      ——  可屏蔽中断INTR</li>
<li>电源掉电 / 奇偶错   ——  非屏蔽中断NMI</li>
</ul>

<hr>

<p>　　所谓<font color="blue">不可屏蔽中断</font>是指该中断请求不能通过软件的方式对其屏蔽，一旦出现NMI中断请求，CPU必须立即响应。 <br>
　　内中断（软中断<code>10H</code>）：</p>

<ul>
<li>INT 指令 / CPU 错（除法错、溢出）</li>
<li>为调试程序设置的中断（t、g命令）</li>
</ul>



<h2 id="80x86-中断源">80x86 中断源</h2>

<p>（图中引线端标示的数字为分配的终端类型号N(0-255)） <br>
<img src="http://img.blog.csdn.net/20170606094805927?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br>
　　8259A外部有28个引脚。有9片8259A可构成64级中断源。</p>



<h2 id="中断向量表">中断向量表</h2>

<p>　　各类型（0~0FFH）中断处理程序的入口地址表 <br>
<img src="http://img.blog.csdn.net/20170606094945041?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>



<h2 id="中断的条件">中断的条件</h2>

<p>（从外设发出中断请求到CPU响应中断，有两个控制条件起决定性作用）：</p>

<ul>
<li>设置CPU中断允许位： <br>
<ul><li>FLAGS 中的<code>IF =  1</code> 的时候<font color="blue">允许中断</font>  （ STI 开中断）<code>IF =  0</code>的时候<font color="red">禁止中断</font> （ CLI 关中断）</li></ul></li>
<li>设置中断屏蔽位： <br>
<ul><li>中断屏蔽寄存器的中断屏蔽位 <code>= 0</code>的时候允许I/O设备请求中断 ,<code>=  1</code> 的时候禁止I/O设备请求中断。</li></ul></li>
</ul>



<h2 id="修改中断处理程序">修改中断处理程序</h2>



<pre class="prettyprint"><code class="language-asm hljs avrasm">DATAS SEGMENT

DATAS ENDS

STACKS SEGMENT
    <span class="hljs-comment">;此处输入堆栈段代码</span>
STACKS ENDS

CODES SEGMENT
    ASSUME CS:CODES,DS:DATAS,SS:STACKS
<span class="hljs-label">START:</span>
    <span class="hljs-keyword">MOV</span> AX,DATAS
    <span class="hljs-keyword">MOV</span> DS,AX

    <span class="hljs-keyword">MOV</span> AL,<span class="hljs-number">0</span>
    <span class="hljs-keyword">MOV</span> AH,<span class="hljs-number">35</span>H
    INT <span class="hljs-number">21</span>H
    <span class="hljs-keyword">PUSH</span> ES
    <span class="hljs-keyword">PUSH</span> BX          <span class="hljs-comment">;保存原向量</span>

    <span class="hljs-keyword">PUSH</span> DS
    <span class="hljs-keyword">MOV</span> AX,SEG FUNCTION
    <span class="hljs-keyword">MOV</span> DS,AX
    <span class="hljs-keyword">MOV</span> DX,OFFSET FUNCTION
    <span class="hljs-keyword">MOV</span> AL,<span class="hljs-number">0</span>
    <span class="hljs-keyword">MOV</span> AH,<span class="hljs-number">25</span>H
    INT <span class="hljs-number">21</span>H          <span class="hljs-comment">;设置新的向量</span>
    <span class="hljs-keyword">POP</span> DS
<span class="hljs-comment">;--------------------主程序部分  </span>
    ……
<span class="hljs-comment">;------------------</span>
    <span class="hljs-keyword">POP</span>  DX
    <span class="hljs-keyword">POP</span>  DS
    <span class="hljs-keyword">MOV</span> AL,<span class="hljs-number">0</span>
    <span class="hljs-keyword">MOV</span> AH,<span class="hljs-number">25</span>H
    INT <span class="hljs-number">21</span>H          <span class="hljs-comment">;恢复原向量    </span>
    <span class="hljs-keyword">MOV</span> AH,<span class="hljs-number">4</span>CH
    INT <span class="hljs-number">21</span>H

<span class="hljs-comment">;--------------中断处理程序</span>
FUNCTION  PROC NEAR
    ……
FUNCTION  ENDP
CODES ENDS
    END START
</code></pre>

<h2 id="cpu中断过程">CPU中断过程</h2>

<ul>
<li>1）取中断类型：CPU ← type  N</li>
<li>2）保护现场：FLAGS、CS、IP入栈</li>
<li>3）IF=0 (关中断),  TF=0（禁止单步中断）</li>
<li>4）计算中断向量地址，取中断向量：<code>（4×N）→ IP</code>，<code>（4×N＋2）→ CS</code>                                      </li>
<li>5）转中断处理程序 <br>
<ul><li>以上步骤都由硬件完成。采用<font color="blue">向量中断</font>的方法，<font color="blue">大大加快了中断处理的速度</font>。因为计算机可直接通过中断向量表转向相应的处理程序，而不需要CPU去逐个检测和确定中断原因。</li></ul></li>
</ul>



<h2 id="int">INT</h2>

<p>　　格式： <code>int n   ; n为中断类型码</code>。 <br>
　　功能：是引发n号中断过程。 <br>
　　CPU 执行<code>int n</code>过程如下：</p>

<ul>
<li>1）取中断类型码n；</li>
<li>2）标志寄存器入栈，<code>IF = 0，TF = 0</code>；</li>
<li>3）CS、IP入栈；</li>
<li>4）<code>(IP) = (n*4)</code>,<code>(CS) = (n*4+2)</code>。 <br>
<ul><li>从此处转去执行n号中断的中断处理程序。</li></ul></li>
</ul>

<hr>

<p>　　或者这么理解：</p>

<ul>
<li>系统功能号送到寄存器AH中</li>
<li>入口参数送到指定的寄存器中</li>
<li>用<code>INT 21H</code>指令执行功能调用</li>
<li>根据出口参数分析功能调用执行情况</li>
</ul>

<table>
<thead>
<tr>
  <th>AH</th>
  <th>功能</th>
  <th>入口参数</th>
  <th>出口参数</th>
</tr>
</thead>
<tbody><tr>
  <td>4CH</td>
  <td>返回DOS</td>
  <td>无</td>
  <td>无</td>
</tr>
<tr>
  <td>1</td>
  <td>键盘输入一个字符到AL中</td>
  <td>无</td>
  <td>AL=字符</td>
</tr>
<tr>
  <td>2</td>
  <td>输出DL寄存器的字符到显示器</td>
  <td>DL（存放一个字符）</td>
  <td>无</td>
</tr>
<tr>
  <td>9</td>
  <td>输出一个以“$”结尾的字符串到显示器</td>
  <td>DS:字符串所在的段地址<br>DX:字符串首地址</td>
  <td>无</td>
</tr>
<tr>
  <td>0AH</td>
  <td>从键盘输入一个字符串到指定缓冲区</td>
  <td>DS:缓冲区所在的段地址<br>DX:缓冲区首地址</td>
  <td>缓冲区相应位置</td>
</tr>
</tbody></table>


<ul>
<li>更多请见： <a href="http://blog.csdn.net/richievoe/article/details/8235873">汇编常用的INT 21H系统调用 </a></li>
</ul>



<h2 id="iret">IRET</h2>

<p>　　可见，<code>INT</code> 指令的最终功能和call指令相似，都是调用一段程序。一般情况下，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用。 <br>
我们在编程的时候，可以用int指令调用这些子程序，而在子程序中安排iret指令返回。我们将这样的中断处理子程序简称为中断例程。 <br>
　　<code>IRET</code>指令的执行过程相当于：       </p>



<pre class="prettyprint"><code class="language-asm hljs perl"><span class="hljs-keyword">pop</span>  ip
<span class="hljs-keyword">pop</span>  cs
<span class="hljs-keyword">pop</span>  flags</code></pre>

<h2 id="中断程序的编写步骤">中断程序的编写步骤</h2>

<p>　　中断处理程序的编写与子程序类似，<font color="blue">先保护现场</font>，再完成功能，然后<font color="blue">恢复现场</font>，最后用<font color="blue">IRET</font>指令返回，返回地址是中断发生时紧接着的下一条指令。</p>

<p>中断处理子程序： <br>
　　保存寄存器内容，如允许中断嵌套，则开中断 ( STI ) <br>
　　中断处理功能 <br>
　　关中断（CLI） <br>
　　送中断结束命令( EOI )给中断命令寄存器 <br>
　　恢复寄存器内容 <br>
　　IRET中断返回 <br>
主程序： <br>
　　1、设置中断向量 <br>
　　2、设置 CPU 的中断允许位<code>IF</code> <br>
　　3、设置设备的中断屏蔽位</p>

<p><img src="http://img.blog.csdn.net/20170606102033569?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<p>　　注意：程序员在编程的时候可以调用系统设置好的中断例程，也可以自己编写中断处理程序。<font color="blue">中断类型号0、1、3、4是固定的内部中断，向量2是非屏蔽中断，向量5~31是保留给系统使用的中断，向量32~255则是用户可用的中断</font>。</p>



<h2 id="示例">示例</h2>

<p>　　编写一个中断处理程序，要求在主程序运行期间，每隔 10秒显示一次字符串‘ bell ’。</p>



<pre class="prettyprint"><code class="language-asm hljs perl">.model small
.stack
.data

cnt  dw <span class="hljs-number">182</span>
mes  db <span class="hljs-string">'bell'</span>,0ah,0dh,<span class="hljs-string">'$'</span>

.code


start:
    mov   ax, <span class="hljs-variable">@data</span>
    mov   ds, ax 
    mov   al,  <span class="hljs-number">1</span>ch   
    mov   ah,  <span class="hljs-number">35</span>h
    <span class="hljs-keyword">int</span>   <span class="hljs-number">21</span>h   ;取向量<span class="hljs-number">1</span>ch
    <span class="hljs-keyword">push</span>  es
    <span class="hljs-keyword">push</span>  bx    ;保存原向量
    <span class="hljs-keyword">push</span>  ds  

    mov   dx,  offset ring
    mov   ax,  seg ring
    mov   ds,  ax
    mov   al,  <span class="hljs-number">1</span>ch
    mov   ah,  <span class="hljs-number">25</span>h
    <span class="hljs-keyword">int</span>   <span class="hljs-number">21</span>h   ;设置新向量
    <span class="hljs-keyword">pop</span>   ds

    in    al,  <span class="hljs-number">21</span>h;中断屏蔽寄存器
    <span class="hljs-keyword">and</span>   al,  <span class="hljs-number">11111110</span>b
    out   <span class="hljs-number">21</span>h, al ;增加定时器中断
    sti  ;开中断</code></pre>

<h1 id="bios和dos中断">BIOS和DOS中断</h1>

<p>　　BIOS是固化在PC机内存地址0FE000开始的8KBROM中的基本输入输出系统的例行程序，它为PC系列的不同微处理器提供了兼容的系统加电自检、引导装入、主要I/O设备的处理程序以及接口控制等功能模块，一般以中断处理程序的形式存在。BIOS可以处理所有的系统中断，如键盘、显示器、磁盘、打印、日期与时间等。BIOS是模块化的结构形式，每个功能模块的入口地址都在中断向量表中，对这些中断调用是通过软中断指令INT来实现的。</p>

<p>　　DOS是IBM PC机的磁盘操作系统，由软盘或硬盘提供。它的两个DOS模块IBMBIO.COM和IBMDOS。COM使BIOS使用起来更方便。其中模块IBMBIO.COM是一个输入输出设备处理程序，提供DOS到BIOS的低级接口，模块IBMDOS。COM包括一个文件管理程序和一些处理程序，把信息传送给IBMBIO.COM，形成BIOS调用。因为DOS模块提供了更多更必要的测试，使DOS操作比使用相应功能的BIOS操作更简易，而且DOS对硬件的依赖性更少些。</p>



<h2 id="用户编程原则">用户编程原则</h2>

<ul>
<li>①尽可能使用DOS的系统功能调用，提高程序可移植性。</li>
<li>②在DOS功能不能实现的情况下，考虑用BIOS功能调用。（比如读打印机状态：BIOS中断17H的功能2）</li>
<li>③在DOS和BIOS的中断子程序不能解决问题时,    才使用IN/OUT指令直接控制硬件。（比如声音控制）</li>
</ul>



<h2 id="中断例程调用方法">中断例程调用方法</h2>

<p>　　一般来说，中断例程中包含多个子程序，内部用AH传递子程序的编号来决定执行哪个子程序。</p>

<p><img src="http://img.blog.csdn.net/20170607103427884?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>



<h1 id="键盘io">键盘I/O</h1>

<ul>
<li>大多数有用的程序都需要处理用户的输入。</li>
<li>键盘输入寄存器的端口地址为60H,控制寄存器的端口地址为61H。</li>
<li>键盘上的每个键都有一个扫描码（01~83）。</li>
<li>◢ 据扫描码可确定操作的是哪个键、是按下键还是释放键；</li>
<li>扫描码用一个字节表示。低7位是扫描码的数字编码（即在键盘上的位置）, 最高位D7位表示键的操作状态： <br>
<ul><li>当按下键时, D7=0 ，取得通码; </li>
<li>当释放键时, D7=1，取得断码。</li></ul></li>
<li>键盘通过键盘接口电路与计算机连接。 当在键盘上“按下”或“放开”一个键时，如果键盘中断是允许的（21H端口的1位等于0），就会产生一个类型9的中断，并转入到BIOS的键盘中断处理程序。</li>
</ul>



<h2 id="bios键盘中断处理程序功能">BIOS键盘中断处理程序功能</h2>

<ul>
<li>◢ 从键盘接口（<font color="blue">60H</font>）读取操作键的扫描码；</li>
<li>◢ 将扫描码转换成字符码（大部分键的字符码即相应字符的ASCII码，没有相应ASCII码的键字符码为0。 ）；</li>
<li>◢ 将键的扫描码、字符码存放在ROM BIOS数据区的键盘缓冲区KB_BUFFER（ <font color="blue">0040:001A</font> ）,   供其它有关键盘的中断子程应用。</li>
</ul>



<h2 id="bios键盘中断int-16h">BIOS键盘中断（INT 16H）</h2>

<table>
<thead>
<tr>
  <th>AH</th>
  <th>功能</th>
  <th>返回参数</th>
</tr>
</thead>
<tbody><tr>
  <td>0</td>
  <td>从键盘读一字符</td>
  <td>AL=字符码，AH=扫描码</td>
</tr>
<tr>
  <td>1</td>
  <td>读键盘状态并检查是否有字符输入</td>
  <td>如按下ZF=0，AL=字符码，AH=扫描码，否则ZF=1，缓冲区空</td>
</tr>
<tr>
  <td>2</td>
  <td>取键盘状态字节</td>
  <td>AH=00，AL=键盘状态字节（KB_FLAG）</td>
</tr>
</tbody></table>


<p><strong>比如指令序列：</strong> </p>



<pre class="prettyprint"><code class="language-asm hljs avrasm"><span class="hljs-keyword">MOV</span>   AH, <span class="hljs-number">0</span>              
INT     <span class="hljs-number">16</span>H        <span class="hljs-comment">;等待按键输入然后取得扫描码和字符码</span>
<span class="hljs-keyword">MOV</span>    BX,AX     <span class="hljs-comment">;用BX传递参数</span>
<span class="hljs-keyword">CALL</span>   BINIHEX  <span class="hljs-comment">;调用子程序将BX转16进制并显示</span></code></pre>

<h3 id="使用int-16h中断例程读取键盘缓冲区">使用int 16h中断例程读取键盘缓冲区</h3>

<ul>
<li>int 16h 中断例程的 0 号功能，进行如下的工作：</li>
<li>1）检测键盘缓冲区中是否有数据；</li>
<li>2）没有则继续做第1 步；</li>
<li>3）读取缓冲区第一个字单元中的键盘输入；</li>
<li>4）将读取的扫描码送入ah，ASCII 码送入al；</li>
<li>5）将己读取的键盘输入从缓冲区中删除。 <br>
<ul><li>可见，B1OS 的int 9 中断例程和int 16h 中断例程是一对相互配合的程序，int 9 中断例程向键盘缓冲区中写入，int 16h 中断例程从缓冲区中读出。</li></ul></li>
</ul>



<h2 id="dos键盘中断int-21h">DOS键盘中断（INT 21H）</h2>

<table>
<thead>
<tr>
  <th>AH</th>
  <th>功能</th>
  <th>调用参数</th>
  <th>返回参数</th>
</tr>
</thead>
<tbody><tr>
  <td>1</td>
  <td>从键盘输入一个字符并回显在屏幕上</td>
  <td></td>
  <td><code>AL =</code>字符</td>
</tr>
<tr>
  <td>6</td>
  <td>读键盘字符，不回显</td>
  <td><code>DL = 0FFH</code></td>
  <td>若有字符可取，<code>AL=</code>字符，<code>ZF=0</code><br> 若无字符可取，<code>AL=0，ZF=1</code></td>
</tr>
<tr>
  <td>7</td>
  <td>从键盘输入一个字符，不回显</td>
  <td></td>
  <td><code>AL =</code>字符</td>
</tr>
<tr>
  <td>A</td>
  <td>输入字符到缓冲区</td>
  <td><code>DS:DX =</code> 缓冲区首址</td>
  <td><code>(DX+1)=</code>实际输入字符数</td>
</tr>
<tr>
  <td>B</td>
  <td>检验键盘状态</td>
  <td></td>
  <td><code>AL=0</code>表示有输入 ，<code>AL=FF</code>表示无输入</td>
</tr>
</tbody></table>




<h3 id="0ah功能的注意事项">0AH功能的注意事项</h3>

<ul>
<li>◢ 输入的字符均带回显，且光标随字符移动。当输入回车符结束时，也回显回车符。表现为功能调用结束后，光标回到了行首。</li>
<li>◢ 回车符0DH作为一个输入的字符存放在字符串尾，但计算输入个数时，不包括回车键。<font color="blue">实际最多能输入的字符数 = 限制的最多数-1 （回车符占一个）</font></li>
<li>◢ 执行完0AH功能后，DS和DX的值不变， DS:DX仍指向缓冲区的首地址。</li>
<li>◢ 整个缓冲区的大小应为:<code>限制的最多数 +2</code>,<code>max  DB  11, ? , 11 dup (?)</code>,<font color="red">缓冲区必须定义为字节类型，不能定义为字类型</font>。</li>
</ul>



<h1 id="显示器io">显示器I/O</h1>

<ul>
<li>1、显示器通过显卡(显示适配器)连接到计算机上。</li>
<li>2、单色显示适配器只能显示黑白两色。只能显示ASCII码字符和一些简单字符图形。</li>
<li>3、彩色显示适配器能以红、绿、蓝彩色显示以点绘制的图形以及ASCII字符。</li>
<li>4、显示器有两种显示方式: <br>
<ul><li>文本方式： <br>
<ul><li>指以字符为单位显示的方式，字符通常是指字母、数字、普通符号和一些特殊符号（如矩形块等）。</li></ul></li>
<li>图形方式： <br>
<ul><li>指以点为单位显示的方式。一个点就是一个像素。</li></ul></li></ul></li>
<li>5、屏幕上各象素的显示信息，存放在显示缓冲区（显存）中。</li>
</ul>



<h2 id="文本方式">文本方式</h2>

<p>　　 <br>
　　将屏幕划分为 m列和n行 (m × n)，在每个网格位置上显示像素，<font color="blue">一个字符是一个像素</font>。在这种显示方式下，<font color="blue">显示缓冲存储区中存放的是字符的ASCII码和对应的显示属性，每个字符占用两个字节的空间</font>。 <br>
<img src="http://img.blog.csdn.net/20170607122327078?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>



<h2 id="图形方式">图形方式:</h2>

<p>　　将屏幕划分为 m×n的点阵，在每个点的位置显示像素，<font color="blue">一个点是一个像素</font>。显示缓冲存储区中存放的是“像素”点的信息，它的值为“0”或者“1”，为“0”就不在屏幕上打点，为“1”则在屏幕上打点。</p>

<p><img src="http://img.blog.csdn.net/20170607123312497?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>



<h2 id="文本方式属性字节的含义">文本方式属性字节的含义</h2>

<p><img src="http://img.blog.csdn.net/20170607123416343?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTm90enVvbm90ZGllZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>



<h3 id="dos显示功能调用中断int-21h">DOS显示功能调用中断（INT 21H）</h3>

<table>
<thead>
<tr>
  <th>AH</th>
  <th>功能</th>
  <th>调用参数</th>
</tr>
</thead>
<tbody><tr>
  <td>2</td>
  <td>显示一个字符(检验Ctrl-Break)</td>
  <td>DL = 字符 <br> 光标跟随字符移动</td>
</tr>
<tr>
  <td>6</td>
  <td>显示一个字符(不检验Ctrl-Break)</td>
  <td>DL = 字符 <br> 光标跟随字符移动</td>
</tr>
<tr>
  <td>9</td>
  <td>显示字符串</td>
  <td>DS:DX=串地址 <br> 串必须以$结束，光标跟随串移动</td>
</tr>
</tbody></table>




<h2 id="显示存储器">显示存储器</h2>

<p>　　MDA显存的起始地址为B000:0000，CGA、EGA、VGA的是B800:0000。 1屏幕的字符数据称为1页数据。据显存大小，可存储若干页的字符象素。 <br>
　　例： 16KB 显存能存储:（1000B=1KB） <br>
　　25×80方式，4页( 0 ~ 3 )， 80×25×2×4 =16000 <br>
　　25×40方式，8页( 0 ~ 7 )， 40×25×2×8 =16000 <br>
　　对CGA、EGA、VGA的80列显示方式，0页显存中的起始地址是B800:0000, 1页B800:1000, 2页B800:2000,3页B800:3000。屏幕上某一字符位置在显存中的偏移地址计算公式： <br>
　　<font color="blue"><strong>Char_offset=Page_offset+((row*width)+column)*byte</strong></font> <br>
　　字符偏移地址=页偏移地址+（（行号 * 行宽）+列号）* 2</p>



<h2 id="bios显示中断int-10h">BIOS显示中断（INT 10H）</h2>

<p>　　功能号 AH=<code>0,1, 2, 3, 5, 6, 7, 8, 9, 0AH, 0EH 13H</code></p>



<h3 id="设置显示方式">设置显示方式</h3>

<ul>
<li>1.入口参数     <code>AL = 显示方式值</code></li>
</ul>

<table>
<thead>
<tr>
  <th>AL显示方式值</th>
  <th>显示点阵大小</th>
  <th>显示方式</th>
</tr>
</thead>
<tbody><tr>
  <td>00</td>
  <td>40×25</td>
  <td>黑白文本方式</td>
</tr>
<tr>
  <td>01</td>
  <td>40×25</td>
  <td>彩色文本方式</td>
</tr>
<tr>
  <td>02</td>
  <td>80×25</td>
  <td>黑白文本方式</td>
</tr>
<tr>
  <td>03</td>
  <td>80×25</td>
  <td>彩色文本方式</td>
</tr>
<tr>
  <td>04</td>
  <td>320×320</td>
  <td>彩色图形方式</td>
</tr>
</tbody></table>


<ul>
<li>2.功能号           <code>AH = 00H</code></li>
<li>3.类型号           <code>10H</code></li>
<li>4.出口参数       无  </li>
<li><p>5.实现功能       将显示方式设置为指定的形式</p>

<p>　　例：   将显示方式设置为 25×80彩色文本方式</p></li>
</ul>



<pre class="prettyprint"><code class="language-asm hljs avrasm"> <span class="hljs-keyword">MOV</span> AL,  <span class="hljs-number">03</span>H
 <span class="hljs-keyword">MOV</span> AH,  <span class="hljs-number">00</span>
 INT <span class="hljs-number">10</span>H</code></pre>

<h2 id="控制光标">控制光标</h2>



<h3 id="隐藏光标">隐藏光标　</h3>

<pre class="prettyprint"><code class="language-asm hljs avrasm"><span class="hljs-comment">;隐藏光标</span>
<span class="hljs-keyword">mov</span> ch,<span class="hljs-number">20</span>h
<span class="hljs-keyword">mov</span> cl,<span class="hljs-number">00</span>h
<span class="hljs-keyword">mov</span> ah,<span class="hljs-number">1</span>
int <span class="hljs-number">10</span>h</code></pre>

<h3 id="光标定位">光标定位</h3>

<p>　　<code>Int 10h</code>的功能<code>02</code>：。 <br>
　　<font color="blue">DH和DL</font>寄存器中为光标位置的行列号，<font color="blue">BH</font>中为页号（单色显示器页号为0 ）。 <br>
　　例：</p>



<pre class="prettyprint"><code class="language-asm hljs avrasm"><span class="hljs-comment">; -------- 设置光标的位置，光标在第5行第6列（4，5）。</span>
<span class="hljs-keyword">mov</span> dh,<span class="hljs-number">4</span>    <span class="hljs-comment">; DH是行号</span>
<span class="hljs-keyword">mov</span> dl,<span class="hljs-number">5</span>    <span class="hljs-comment">; DL是列号</span>
<span class="hljs-keyword">mov</span> bh,<span class="hljs-number">0</span>    <span class="hljs-comment">; BH是页号</span>
<span class="hljs-keyword">mov</span> ah,<span class="hljs-number">2</span>    <span class="hljs-comment">; 2号功能</span>
int <span class="hljs-number">10</span>h</code></pre>

<h3 id="读光标位置">　读光标位置</h3>

<p>　　功能03 ：<code>BH</code>中指定页号。把光标位置的行号回送给<code>DH</code>,列号回送给<code>DL</code>,光标大小的参数填入<code>CH</code>和<code>CL</code> 。</p>



<pre class="prettyprint"><code class="language-asm hljs avrasm"><span class="hljs-keyword">mov</span> ah,<span class="hljs-number">3</span>
<span class="hljs-keyword">mov</span> bh,<span class="hljs-number">0</span> 
int <span class="hljs-number">10</span>h    <span class="hljs-comment">;返回参数dh:dl=行：列</span></code></pre>

<h3 id="清屏和卷屏">清屏和卷屏</h3>

<p>　　功能06（07）：使屏幕内容上卷（或下卷）指定的行。需要7个参数。 <br>
　　例：清除屏幕</p>



<pre class="prettyprint"><code class="language-asm hljs avrasm"><span class="hljs-keyword">mov</span> ah, <span class="hljs-number">6</span>   <span class="hljs-comment">; ah=功能号</span>
<span class="hljs-keyword">mov</span> al, <span class="hljs-number">0</span>   <span class="hljs-comment">; al=指定行数（为0全屏幕空白）</span>
<span class="hljs-keyword">mov</span> bh, <span class="hljs-number">70</span>h <span class="hljs-comment">; bh=卷入行属性(白底黑字 )</span>

<span class="hljs-comment">; -------- 定义窗口属性</span>
<span class="hljs-keyword">mov</span> ch, <span class="hljs-number">0</span>   <span class="hljs-comment">; ch=左上角行号</span>
<span class="hljs-keyword">mov</span> cl, <span class="hljs-number">0</span>   <span class="hljs-comment">;cl= 左上角列号</span>
<span class="hljs-keyword">mov</span> dh, <span class="hljs-number">24</span>  <span class="hljs-comment">; dh=右下角行号</span>
<span class="hljs-keyword">mov</span> dl, <span class="hljs-number">79</span>  <span class="hljs-comment">;dl= 右下角列号</span>
<span class="hljs-comment">; -------- 定义窗口属性</span>

int <span class="hljs-number">10</span>h     <span class="hljs-comment">; BIOS调用类型10h   </span></code></pre>

<h3 id="显示字符及字符串">显示字符及字符串</h3>

<p>　　 <br>
　　功能9（<code>0a</code>）: 把一个字符送到显示屏幕，可直接在cx中设定显示次数，调用结束后光标返回它的初始位置。（0a以正常属性显示） <br>
　　功能8：读取当前光标位置的字符和属性，入口参数<code>bh=显示页号</code>，返回<code>ah/al=字符/属性</code>。 <br>
　　例:  在品红背景下，显示5个浅绿色闪烁的星号。（闪烁很快几乎觉察不到）      </p>



<pre class="prettyprint"><code class="language-asm hljs avrasm"><span class="hljs-keyword">MOV</span> AH，<span class="hljs-number">09</span>    <span class="hljs-comment">; 光标位置下显示</span>
<span class="hljs-keyword">MOV</span> AL，<span class="hljs-string">'*'</span>   <span class="hljs-comment">; 显示字符</span>
<span class="hljs-keyword">MOV</span> BH，<span class="hljs-number">0</span>     <span class="hljs-comment">; 显示页0</span>
<span class="hljs-keyword">MOV</span> BL，<span class="hljs-number">0</span>DAH  <span class="hljs-comment">; 1 101 1010 </span>
<span class="hljs-keyword">MOV</span> CX，<span class="hljs-number">05</span>    <span class="hljs-comment">; 显示次数</span>
INT <span class="hljs-number">10</span>H       <span class="hljs-comment">; BIOS调用</span></code></pre>

<h3 id="显示字符串">显示字符串</h3>

<ul>
<li>功能<code>13H</code>:显示字符串。</li>
<li>参数： <br>
<ul><li>ES:BP=字符串地址</li>
<li>AL=写方式（0~3）</li>
<li>CX=字符串长度</li>
<li>DH/DL=起始行/列</li>
<li>BH/BL=页号/属性</li></ul></li>
<li>子功能号 <br>
<ul><li>AL=0,1，要指定整个显示字符串的属性。</li>
<li>AL=2,3，必须指定每个字符的属性。</li></ul></li>
</ul>



<h1 id="显示系统时间">显示系统时间</h1>



<pre class="prettyprint"><code class="language-asm hljs avrasm">DATAS SEGMENT
   CLOCK DB <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-string">':'</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-string">':'</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-string">'$'</span>
DATAS ENDS
CODES SEGMENT
    ASSUME CS:CODES,DS:DATAS
<span class="hljs-label">START:</span>
    <span class="hljs-keyword">MOV</span> AX,DATAS
    <span class="hljs-keyword">MOV</span> DS,AX
<span class="hljs-label">RESTART:</span>
    LEA BX,CLOCK
    <span class="hljs-keyword">MOV</span> AL,<span class="hljs-number">4</span>
    <span class="hljs-keyword">CALL</span> GETTIME
    <span class="hljs-keyword">MOV</span> AL,<span class="hljs-number">2</span>
    <span class="hljs-keyword">CALL</span> GETTIME
    <span class="hljs-keyword">MOV</span> AL,<span class="hljs-number">0</span>
    <span class="hljs-keyword">CALL</span> GETTIME

    <span class="hljs-comment">;------ 设置光标位置</span>
    <span class="hljs-keyword">MOV</span> DH,<span class="hljs-number">10</span> <span class="hljs-comment">;行</span>
    <span class="hljs-keyword">MOV</span> DL,<span class="hljs-number">30</span> <span class="hljs-comment">;列</span>
    <span class="hljs-keyword">MOV</span> BH,<span class="hljs-number">0</span>
    <span class="hljs-keyword">MOV</span> AH,<span class="hljs-number">2</span>
    INT <span class="hljs-number">10</span>H

    <span class="hljs-comment">;------ 隐藏光标</span>
    <span class="hljs-keyword">MOV</span> CH,<span class="hljs-number">20</span>H
    <span class="hljs-keyword">MOV</span> CL,<span class="hljs-number">00</span>H
    <span class="hljs-keyword">MOV</span> AH,<span class="hljs-number">1</span>
    INT <span class="hljs-number">10</span>H

    <span class="hljs-comment">;------ 输出时间</span>
    LEA DX,CLOCK
    <span class="hljs-keyword">MOV</span> AH,<span class="hljs-number">9</span>
    INT <span class="hljs-number">21</span>H 

    <span class="hljs-comment">; ------ 检测键盘输入。</span>
    <span class="hljs-keyword">IN</span> AL,<span class="hljs-number">60</span>H
    CMP AL,<span class="hljs-number">1</span>
    JNZ RESTART   <span class="hljs-comment">;按下ESC退出，不断更新时间</span>
    <span class="hljs-keyword">MOV</span> AH,<span class="hljs-number">4</span>CH
    INT <span class="hljs-number">21</span>H   

    <span class="hljs-comment">; ------ 获取时间  入口参数：AL</span>
GETTIME PROC
    <span class="hljs-comment">; ------ 读取数据</span>
    <span class="hljs-keyword">OUT</span> <span class="hljs-number">70</span>H,AL <span class="hljs-comment">; 设定读数地址</span>
    <span class="hljs-keyword">IN</span> AL,<span class="hljs-number">71</span>H  <span class="hljs-comment">; 取数</span>

    <span class="hljs-comment">; ------ 左移四位得到十位数值</span>
    <span class="hljs-keyword">MOV</span> AH,<span class="hljs-number">0</span>    <span class="hljs-comment">;清零</span>
    <span class="hljs-keyword">MOV</span> CL,<span class="hljs-number">4</span>
    SHL AX,CL

    SHR AL,CL   <span class="hljs-comment">; 得到个位数值 </span>
    <span class="hljs-keyword">ADD</span> AH,<span class="hljs-number">30</span>H  <span class="hljs-comment">; 转换成ASCII</span>
    <span class="hljs-keyword">ADD</span> AL,<span class="hljs-number">30</span>H  <span class="hljs-comment">; 转换成ASCII</span>
    <span class="hljs-keyword">MOV</span> CLOCK[BX],AH
    <span class="hljs-keyword">MOV</span> CLOCK[BX+<span class="hljs-number">1</span>],AL
    <span class="hljs-keyword">ADD</span> BX,<span class="hljs-number">3</span>    <span class="hljs-comment">; 跳过三个字符-&gt;':'</span>
    <span class="hljs-keyword">RET</span>
GETTIME ENDP     
CODES ENDS
    END START</code></pre>

